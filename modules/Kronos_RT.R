#!/usr/local/bin/Rscript
#parse input
suppressPackageStartupMessages(library(optparse, quietly = TRUE))

options(stringsAsFactors = FALSE)
options(warn = 1, scipen = 999)

option_list = list(
    make_option(
        c("-K", "--Kronos_conf_file"),
        type = "character",
        default = NULL,
        help = "Kronos setting file. If provided -F,-T,-S,-b and -g are ignored. Tab file containing: Per cell stat file <TAB> tracks file <TAB> settings file <TAB> basename (optional) <TAB> group (optional) ",
        metavar = "character"
    ),make_option(
        c("-F", "--file"),
        type = "character",
        default = NULL,
        help = "Per cell stat file , if multiple files are provided they have to be separated by a comma",
        metavar = "character"
    ),
    make_option(
        c("-T", "--tracks"),
        type = "character",
        default = NULL,
        help = "Tracks file,  if multiple files are provided they have to be separated by a comma",
        metavar = "character"
    ),
    make_option(
        c("-R", "--referenceRT"),
        type = "character",
        default = NULL,
        help = "Reference RT min=Late, max=Early, only one reference is allowed",
        metavar = "character"
    ),
    make_option(
        c("--ref_name"),
        type = "character",
        default = "Reference",
        help = "Name for the reference track [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-C", "--chrSizes"),
        type = "character",
        default = NULL,
        help = "Chromosome size file",
        metavar = "character"
    ),
    make_option(
        c("-r", "--region"),
        type = "character",
        default = NULL,
        help = "Region to plot  chr:start-end (multiple regins can be separated by a comma) or provided as a bed file",
        metavar = "character"
    ),
    make_option(
        c("-o", "--out"),
        type = "character",
        default = "output",
        help = "Output directory [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-b", "--base_name"),
        type = "character",
        default = "exp",
        help = "Base name for files names [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-f", "--output_file_base_name"),
        type = "character",
        default = "out",
        help = "Base name for the output file [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-g", "--groups"),
        type = "character",
        help = "Grouping names of multiple basenames [default= base_name]",
        metavar = "character"
    ),
    make_option(
        c("-S", "--settings_file"),
        type = "character",
        help = "File generated by Kronos diagnostic",
        metavar = "character"
    ),
    make_option(
        c("-B", "--binsSize"),
        type = "character",
        default = '500Kb',
        help = "RT resolution (supports units) [default= %default] ",
        metavar = "character"
    ),
    make_option(
        c("-c", "--cores"),
        type = "integer",
        default = 3,
        help = "Numbers of parallel jobs to run [default= %default]",
        metavar = "integer"
    ),
    make_option(
        c("-N", "--N_of_RT_groups"),
        type = "integer",
        default = 2,
        help = "Number of RT groups: either 2,3 or 5 [default= %default]",
        metavar = "integer"
    ),
    make_option(
        c("-p", "--plot"),
        type = "logical",
        default = F,
        action = "store_true",
        help = "If selected prints some randome regins, if -r is selected those regins are use to print RT [default= %default] ",
        metavar = "logical"
    ),
    make_option(
        c("--Var_against_reference"),
        type = "logical",
        default = F,
        action = "store_true",
        help = "Variability metrics are calculated usign reference RT in addiction to the calculated one [default= %default] ",
        metavar = "logical"
    ),
    make_option(
        c("--disable_symmetry"),
        type = "logical",
        default = F,
        action = "store_true",
        help = "If symmetry is disabled, all cells will be used to calculate the scRT [default= %default]",
        metavar = "logical"
    ),
    make_option(
        c("--min_correlation"),
        type = "double",
        default = 0.25,
        help = "Minimum correlation value between one cell and its best correlating cell for this cell to not be discarded [default= %default]",
        metavar = "double"
    ),
    make_option(
        c("--extract_G1_G2_cells"),
        type = "logical",
        default = F,
        action = "store_true",
        help = "Extract G1/G2 single cells copy numebr file [default= %default]",
        metavar = "logical"
    ),
    make_option(
        c("--chr_prefix"),
        type = "character",
        action = 'store',
        help = "Chromosome prefix, if there is no prefix use none [default= %default]",
        default = "chr",
        metavar = "character"
    ),
    make_option(
        c("--chr_range"),
        type = "character",
        action = 'store',
        help = "Chromosomes to consider in the analysis (example 1:5,8,15:18,X) [default= %default]",
        default = "1:22",
        metavar = "character"
    )
)

#recover inputs
opt = parse_args(object = OptionParser(option_list = option_list))

#load libraries
suppressPackageStartupMessages(library(tidyverse, quietly = TRUE))
suppressPackageStartupMessages(library(GGally, quietly = TRUE))
suppressPackageStartupMessages(library(ggcorrplot, quietly = TRUE))
suppressPackageStartupMessages(library(foreach, quietly = TRUE))
suppressPackageStartupMessages(library(doSNOW, quietly = TRUE))
suppressPackageStartupMessages(library(gplots, quietly = TRUE))
suppressPackageStartupMessages(library(matrixStats, quietly = TRUE))
suppressPackageStartupMessages(library(RColorBrewer, quietly = TRUE))
suppressPackageStartupMessages(library(GenomicRanges, quietly = TRUE))
suppressPackageStartupMessages(library(MASS, quietly = TRUE))
suppressPackageStartupMessages(library(ade4, quietly = TRUE))


#set plotting theme
theme_set(theme_bw())

#check inputs
if('Kronos_conf_file' %in% names(opt)) {
    
    if(!file.exists(opt$Kronos_conf_file)){
        stop('Provided setting file does not exist')
    }
    
    settings=tryCatch(expr = read_tsv(opt$Kronos_conf_file,col_names = c('file','traks','settings','basename','groups'),col_types = cols())%>%
                          mutate(
                              basename=ifelse(is.na(basename),paste0('exp',row_number()),basename),
                              groups=ifelse(is.na(groups),basename,groups)
                          ),
                      error=function(e){stop('Settings file does not exitst. See script usage (--help)')},
                      warning=function(w){
                          tmp=suppressWarnings(
                              read_tsv(opt$Kronos_conf_file,col_names = c('file','traks','settings','basename','groups'),col_types = cols())%>%
                                  mutate(
                                      basename=ifelse(is.na(basename),paste0('exp',row_number()),basename),
                                      groups=ifelse(is.na(groups),basename,groups)
                                  ))
                          warning('missing basenames and groups were replaced with default parameters')
                          return(tmp)})
    
    #reformat files
    opt$file = settings$file
    
    opt$settings_file = settings$settings
    
    opt$tracks = settings$traks
    
    opt$base_name = settings$basename
    
    opt$groups = settings$groups
    
} else{
    
    if (!'file' %in% names(opt)) {
        stop("Per cell stat file or Kronos setting file must be provided. See script usage (--help)")
    }
    
    if (!'tracks' %in% names(opt)) {
        stop("File containing cells CNV or Kronos setting file must be provided. See script usage (--help)")
    }
    
    if (!'settings_file' %in% names(opt)) {
        stop("File containing settings sizes must be provided. See script usage (--help)")
    }
    
    if (!'groups' %in% names(opt)) {
        opt$groups = opt$base_name
    }
    
    #reformat files
    opt$file = str_split(opt$file, ',')[[1]]
    
    opt$settings_file = str_split(opt$settings_file, ',')[[1]]
    
    opt$tracks = str_split(opt$tracks, ',')[[1]]
    
    opt$base_name = str_split(opt$base_name, ',')[[1]]
    
    opt$groups = str_split(opt$groups, ',')[[1]]
    
    
}    

if (!'chrSizes' %in% names(opt)) {
    stop("File containing Chromosomes sizes must be provided. See script usage (--help)")
}

if (opt$Var_against_reference) {
    if (!'referenceRT' %in% names(opt)) {
        warning("Reference genome not provided")
        opt$Var_against_reference = F
    }
}

#does exist/ right format function
does_exist_right_format = Vectorize(function(File, delim = '\t', columns_to_check,message='does not have the proper format') {
    #checks if the file exist
    if (!file.exists(File)) {
        return(paste(File, 'does not exist'))
    } else{
        # if columns_to_check is numeric check the number of colums
        if(is.numeric(columns_to_check)){
            if (ncol(tryCatch(
                expr =  read_delim(
                    File,
                    col_types = cols(),
                    n_max = 0,
                    delim = delim
                ),
                error = function(x)
                    tibble()
            ))!=columns_to_check) {
                return(paste(File, message,'\n'))
            } else{
                return('')
            }
        
        # if columns_to_check is not numeric check columns names    
        }else{
        #checks if it has the right format
        if (!all(columns_to_check %in% colnames(tryCatch(
            expr =  read_delim(
                File,
                col_types = cols(),
                n_max = 0,
                delim = delim
            ),
            error = function(x)
                tibble()
        )))) {
            return(paste(File, message,'\n'))
        } else{
            return('')
        }
    }
    }
    
}, vectorize.args = 'File')

#check per cell files 
results=paste(does_exist_right_format(File=opt$file,delim = ',',columns_to_check=c('Cell',
                                                                     'normalized_dimapd',
                                                                     'mean_ploidy',
                                                                     'ploidy_confidence',
                                                                     'is_high_dimapd',
                                                                     'is_noisy',
                                                                     'coverage_per_1Mbp'),
                                     message = ',provided as a per cell file, does not have the right format'),collapse = '')
if(results!='') {
    stop(results)
}

#check tracks files 
results=paste(does_exist_right_format(File=opt$tracks,delim = '\t',columns_to_check=c('Cell',
                                                                                  'chr',
                                                                                  'start',
                                                                                  'end',
                                                                                  'copy_number',
                                                                                  'reads'),
                                     message = ',provided as a track file, does not have the right format'),collapse = '')
if(results!='') {
    stop(results)
}
#check settings files 
results=paste(does_exist_right_format(File=opt$settings_file,delim = '\t',columns_to_check=c('threshold_Sphase',
                                                                                     'threshold_G1G2phase',
                                                                                     'Sphase_first_part',
                                                                                     'Sphase_second_part',
                                                                                     'RPM_TH'),
                                     message = ',provided as a setting file, does not have the right format'),collapse = '')
if(results!='') {
    stop(results)
}

#check chr size file
results=paste(does_exist_right_format(File=opt$chrSizes,delim = '\t',columns_to_check=2,
                                     message = ',provided as a chromosome size file, does not have the right format'),collapse = '')

if(results!='') {
    stop(results)
}

#check reference file if provided
if ('referenceRT' %in% names(opt)) {
    
    results=paste(does_exist_right_format(File=opt$referenceRT,delim = '\t',columns_to_check=4,
                                         message = ',provided as a reference RT file, does not have the right format'),collapse = '')
    
    if(results!='') {
        stop(results)
    }   
}

# convert binsize to numeric
extract_unit = str_extract(opt$binsSize, pattern = '.{2}$')
resolution = as.numeric(str_remove(opt$binsSize, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]")) * case_when(
    grepl(x = extract_unit, pattern =  '[Kk][Bb]') ~ 1000,
    grepl(x = extract_unit, pattern = '[Mm][Bb]') ~ 1000000,
    grepl(x = extract_unit, pattern = '[Bp][Pp]') ~ 1,
    grepl(x = extract_unit, pattern =  '[0-9][0-9]') ~ 1
)

if (any(is.na(resolution))) {
    stop('binsize have an incorrect format')
}

# prepare name file
if (grepl(x = extract_unit, pattern =  '[0-9][0-9]')) {
    n_of_zeros = str_length(str_extract(opt$binsSize, '0{1,10}$'))
    opt$binsSize = case_when(
        is.na(n_of_zeros) ~ paste0(opt$binsSize, 'bp'),
        n_of_zeros < 3 ~ paste0(opt$binsSize, 'bp'),
        n_of_zeros < 6 ~ paste0(str_remove(opt$binsSize, '0{3}$'), 'Kb'),
        n_of_zeros >= 6 ~ paste0(str_remove(opt$binsSize, '0{6}$'), 'Mp')
    )
} else{
    opt$binsSize = opt$binsSize
}

#create directory
if (str_extract(opt$out, '.$') != '/') {
    opt$out = paste0(opt$out, '/')
}

system(paste0('mkdir -p ', opt$out))


# check inputs
if (length(opt$tracks) != length(opt$file)) {
    stop("The number stat files does not match provided trakcs. See script usage (--help)")
}

if (length(opt$base_name) != length(opt$file)) {
    index = rep(
        1:length(opt$file),
        length(opt$file),
        each = length(opt$base_name),
        length.out = length(opt$file)
    )
    opt$base_name = paste(rep_len(opt$base_name, length(opt$file)), index, sep = '-')
    warning('basenames will be cyclically recycled')
}

if (length(opt$groups) != length(opt$file)) {
    index = rep(
        1:length(opt$file),
        length(opt$file),
        each = length(opt$groups),
        length.out = length(opt$file)
    )
    opt$groups = paste(rep_len(opt$groups, length(opt$groups)), index, sep = '-')
    warning('groups variable will be cyclically recycled')
}


# select chrs of interest
# convert string into range
Convert_to_range = Vectorize(function(x){
    if (str_detect(x, ':')) {
        x = str_split(x, ':')[[1]]
        return(as.numeric(x[1]):as.numeric(x[2]))
    } else{
        return(x)
    }
})

#select chrs
chr_list = paste0(ifelse(opt$chr_prefix=='none','',opt$chr_prefix), unlist(Convert_to_range(str_split(opt$chr_range,',')[[1]])))

#load genome sizes
Chr_Size=read_tsv(opt$chrSizes,col_names =c('chr','size'),col_types = cols(chr='c'))%>%
    filter(chr %in% chr_list)%>%
    mutate(chr = factor(x =  chr, levels = chr_list)) %>%
    drop_na()

chr_list = chr_list[chr_list %in% unique(Chr_Size$chr)]


#load single cells info
data <-
    foreach(
        i = 1:length(opt$file),
        .combine = 'rbind',
        .packages = 'tidyverse'
    ) %do% {
        inner_join(
            read_csv(opt$file[i], col_types = cols()) %>%
                mutate(
                    basename = factor(opt$base_name[i], levels = opt$base_name),
                    group = factor(opt$groups[i], levels = unique(opt$groups))
                ),
            read_tsv(opt$settings_file[i], col_types = cols()) %>%
                mutate(
                    basename = factor(opt$base_name[i], levels = opt$base_name),
                    group = factor(opt$groups[i], levels = unique(opt$groups))
                ),
            by = c('basename', 'group')
        )
    }

#filter data with too little reads per megabase 
data = data %>% filter(coverage_per_1Mbp >= RPM_TH)

#load tracks
all_tracks <-
    foreach(
        i = 1:length(opt$tracks),
        .combine = 'rbind',
        .packages = 'tidyverse'
    ) %do% {
        read_delim(opt$tracks[i], delim = '\t', col_types = cols(chr='c')) %>%
            mutate(
                basename = factor(opt$base_name[i], levels = opt$base_name),
                group = factor(opt$groups[i], levels = unique(opt$groups)),
                chr = factor(x =  chr, levels = chr_list)
            ) %>%
            drop_na()
    }

# remove tracks not in use
CB = data %>%
    dplyr::select(Cell, basename)

all_tracks = all_tracks %>%
    inner_join(CB, by = c("Cell", "basename"))

rm('CB')

if ('referenceRT' %in% names(opt)) {
    Reference_RT <-
        read_delim(
            opt$referenceRT,
            delim = '\t',
            col_names = c('chr', 'start', 'end', 'RT'),
            col_types = cols(chr='c')
        ) %>%
        mutate(chr = factor(x =  chr, levels = chr_list))
}

# calculate the new is_high_dimapd
data = data %>%
    mutate(
        is_noisy = as.logical(is_noisy),
        is_high_dimapd = ifelse(
            is.na(threshold_Sphase),
            is_high_dimapd,
            ifelse(normalized_dimapd > threshold_Sphase, T, F)
        ),
        is_noisy = ifelse(is_high_dimapd, T, is_noisy)
    )

median_ploidy_G1_G2_cells = data %>%
    filter(ifelse(
        is.na(threshold_G1G2phase),
        is_noisy == F,
        is_noisy == F &
            normalized_dimapd < threshold_G1G2phase
    )) %>%
    group_by(basename) %>%
    summarise(median_ploidy_G1_G2_cells = median(mean_ploidy))

data = data %>%
    inner_join(median_ploidy_G1_G2_cells, by = 'basename') %>%
    filter(
        mean_ploidy > median_ploidy_G1_G2_cells / 1.50 ,
        mean_ploidy < median_ploidy_G1_G2_cells * 2,
        !ploidy_confidence <= 2 | ploidy_confidence == -100
    ) %>%
    mutate(Type = ifelse(
        as.logical(is_high_dimapd) == T &
            as.logical(is_noisy) == T,
        'S-phase cells',
        ifelse(
            ifelse(
                is.na(threshold_G1G2phase),
                as.logical(is_high_dimapd) == F &
                    as.logical(is_noisy) == F,
                as.logical(is_high_dimapd) == F &
                    as.logical(is_noisy) == F &
                    normalized_dimapd < threshold_G1G2phase
            ),
            'G1/G2-phase cells',
            'unknown cells'
        )
    ))

#plot Variability vs ploidy
p = data %>%
    ggplot(aes(mean_ploidy,
               normalized_dimapd,
               color = Type)) +
    geom_point(alpha = 0.3) +
    scale_color_manual(
        values = c(
            'G1/G2-phase cells' = "#005095",
            'S-phase cells' = "#78bd3e",
            'unknown cells' = "#dfbd31"  
        )
    ) +
    theme(legend.position = 'top', legend.title = element_blank()) +
    geom_vline(aes(xintercept = median_ploidy_G1_G2_cells)) + facet_wrap(group ~
                                                                             basename, scales = 'free') +
    xlab('Ploidy') + ylab('Variability')

suppressMessages(ggsave(
    p,
    filename = paste0(opt$out, '/', opt$output_file_base_name, '_plot.pdf')
))

# correct mean ploidy late S phase
data = data %>%
    mutate(
        mean_ploidy_corrected = ifelse(
            as.logical(is_noisy) == T &
                mean_ploidy < median_ploidy_G1_G2_cells,
            mean_ploidy / Sphase_second_part,
            ifelse(
                as.logical(is_noisy) == T &
                    mean_ploidy > median_ploidy_G1_G2_cells,
                mean_ploidy / Sphase_first_part,
                mean_ploidy
            )
        )
    )

#plot Variability vs ploidy (after correction)
p = data %>%
    ggplot(aes(mean_ploidy_corrected, normalized_dimapd, color = Type)) +
    geom_point(alpha = 0.3) +
    scale_color_manual(
        values = c(
            'G1/G2-phase cells' = "#005095",
            'S-phase cells' = "#78bd3e",
            'unknown cells' = "#dfbd31"  
        )
    ) +
    theme(legend.position = 'top', legend.title = element_blank()) +
    geom_vline(aes(xintercept = median_ploidy_G1_G2_cells)) + facet_wrap(group ~
                                                                             basename, scales = 'free') +
    xlab('Ploidy') + ylab('Variability')

suppressMessages(ggsave(
    p,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_plot_sphase_corrected.pdf'
    )
))

#resolution
cl <- makeCluster(opt$cores)
registerDoSNOW(cl)

bins = foreach(chr = 1:length(Chr_Size$chr),
               .combine = 'rbind') %dopar% {
                   bins = seq(from = resolution,
                              to = Chr_Size$size[chr] ,
                              by =  resolution)
                   bins = data.frame(
                       chr =  factor(x =  Chr_Size$chr[chr], levels = chr_list),
                       start = bins - resolution,
                       end = bins
                   )
                   bins
               }

stopCluster(cl)

#convert bins into granges
bins = bins %>%
    GenomicRanges::makeGRangesListFromDataFrame(
        seqnames.field  = 'chr',
        start.field = 'start' ,
        end.field = 'end'
    )

#rebin data
Rebin<- function(PerCell,scCN,Bins,Sphase=NULL) {
    
    if(!is.logical(Sphase)){
        stop('Sphase must be set as True or False')
    }
    
    if(Sphase){
        selected_data = PerCell %>%
            dplyr::filter(Type == 'S-phase cells') %>%
            dplyr::arrange(mean_ploidy_corrected) %>%
            dplyr::mutate(index = 1:dplyr::n()) %>%
            dplyr::select(index,
                          Cell,
                          mean_ploidy,
                          mean_ploidy_corrected,
                          basename,
                          group)

    }else{
        selected_data=PerCell%>%
            dplyr::filter(Type == 'G1/G2-phase cells') %>%
            mutate(index = as.numeric(factor(Cell)))%>%
            dplyr::select(index,
                          Cell,
                          mean_ploidy,
                          mean_ploidy_corrected,
                          basename,
                          group)

    }
    
    scCN = scCN%>%
        dplyr::inner_join(selected_data, by = c('Cell', 'basename', 'group')) %>%
        dplyr::mutate(
            copy_number_corrected = ifelse(
                mean_ploidy == mean_ploidy_corrected,
                copy_number,
                copy_number * mean_ploidy_corrected / mean_ploidy
            )
        )
    #convert into Granges
    scCN = scCN %>%
        GenomicRanges::makeGRangesFromDataFrame(
            seqnames.field  = 'chr',
            start.field = 'start' ,
            end.field = 'end',
            keep.extra.columns = T
        )
    
    #calculate median CN across a bin
    hits = IRanges::findOverlaps(Bins, scCN)
    
    #recover info
    scCN = cbind(
        dplyr::as_tibble(Bins[S4Vectors::queryHits(hits)]) %>% dplyr::select(seqnames, start, end) %>%
            `colnames<-`(c('chr', 'start', 'end')),
        dplyr::as_tibble(scCN[S4Vectors::subjectHits(hits)]) %>% dplyr::select(-seqnames, -start, -end)
    ) %>%
        dplyr::group_by(Cell, index, basename, group, chr, start, end) %>%
        dplyr::summarise(CN = matrixStats::weightedMedian(
            x = copy_number_corrected,
            w = width,
            na.rm = T
        )) %>%
        dplyr::ungroup()
    
    return(scCN)
}

signal_smoothed = Rebin(
    PerCell = data,
    scCN = all_tracks,
    Bins = bins,
    Sphase = T
)

G1G2_smoothed = Rebin(
    PerCell = data,
    scCN = all_tracks,
    Bins = bins,
    Sphase = F
)

#free some memory
rm('all_tracks')

#calculate background
backgroud_smoothed=G1G2_smoothed%>%
    group_by(basename, group, chr, start, end)%>%
    summarise(background=median(CN))

# binarizes data into Replicated or not replicated bins
Replication_state = function(Samples, background, chr_list,cores=3){
    
    cl <- makeCluster(cores)
    registerDoSNOW(cl)
    #merge signal and bg and calculate their ratio
    Samples = Samples %>%
        ungroup() %>%
        mutate(chr = factor(x =  chr, levels = chr_list)) %>%
        inner_join(background,
                   by = c("chr", "start", "end", "basename", 'group')) %>%
        mutate(CN_bg = log2(CN / background)) %>%
        drop_na() %>%
        filter(is.finite(CN_bg))
    
    # identify threshold that minimazes the difference of the real data with a binary state (1 or 2)
    selecte_th = foreach(
        line = unique(Samples$basename),
        .combine = 'rbind',
        .packages = c('foreach', 'tidyverse')
    ) %dopar% {
        sub_sig = Samples %>%
            filter(basename == line)
        
        #identify range within looking for a CNV treshold to define replicated and not replicated values
        range = seq(0, 1, 0.01)
        
        th_temp = foreach(i = range,
                          .combine = 'rbind',
                          .packages = 'tidyverse') %do% {
                              summary = sub_sig %>%
                                  mutate(Rep = ifelse(CN_bg >= i, T, F),
                                         Error = (Rep - CN_bg) ^ 2) %>%
                                  group_by(Cell, index, basename, group)  %>%
                                  summarise(summary = sum(Error))
                              
                              data.frame(
                                  th = i,
                                  basename = summary$basename,
                                  index = summary$index,
                                  sum_error = summary$summary
                              )
                          }
        th_temp
    }
    
    selecte_th = selecte_th %>%
        group_by(index, basename) %>%
        filter(sum_error == min(sum_error)) %>%
        summarise(th = min(th)) %>%
        ungroup()
    
    # mark replicated bins
    Samples = Samples %>%
        inner_join(selecte_th, by = c("index", "basename")) %>%
        mutate(Rep = ifelse(CN_bg >= th, T, F))
    
    #identify new distribution in the S phase based the ammount of replicated bins
    new_index_list = Samples %>%
        group_by(Cell, index, basename, group) %>%
        summarise(PercentageReplication = mean(Rep)) %>%
        ungroup() %>%
        arrange(PercentageReplication) %>%
        group_by(group) %>%
        mutate(newIndex = 1:n()) %>%
        dplyr::select(oldIndex = index, newIndex, Cell, basename, group,PercentageReplication)
    
    Samples = Samples %>%
        inner_join(new_index_list,
                   by = c('Cell', 'index' = 'oldIndex', 'basename', 'group'))
    
    stopCluster(cl)
    
    
    return(Samples)
}

if(opt$extract_G1_G2_cells){
    # create single G1/G2 single cell file
    G1G2_smoothed = Replication_state(Samples = G1G2_smoothed,
                                      background = backgroud_smoothed,
                                      chr_list = chr_list,cores = opt$cores)
        
  #write results
    G1G2_smoothed%>%
        dplyr::select(chr,
                      start,
                      end,
                      CN,
                      background,
                      CN_bg,
                      th,
                      Rep,
                      PercentageReplication,
                      Cell,
                      basename,
                      group,
                      newIndex)%>%
        write_delim(
            file = paste0(
                opt$out,
                '/',
                opt$output_file_base_name,
                '_G1_G2_single_cells_CNV_',
                opt$binsSize,
                '.tsv'
            ),
            delim = '\t',
            col_names = T
        )
    
}
#free some space
rm('G1G2_smoothed')

if ('referenceRT' %in% names(opt)) {
    # rebin reference RT
    Reference_RT = Reference_RT %>%
        drop_na() %>%
        makeGRangesFromDataFrame(
            seqnames.field = 'chr',
            start.field = 'start',
            end.field = 'end',
            keep.extra.columns = T
        )
    
    hits = findOverlaps(bins, Reference_RT)
    
    Reference_RT = cbind(
        as_tibble(bins[queryHits(hits)]) %>% dplyr::select(seqnames, start, end) %>%
            `colnames<-`(c('chr', 'start', 'end')),
        as_tibble(Reference_RT[subjectHits(hits)]) %>% dplyr::select(-seqnames, -start, -end)
    ) %>%
        group_by(chr, start, end) %>%
        summarise(RT = weightedMedian(x = RT, w =
                                          width, na.rm = T)) %>%
        ungroup() %>%
        mutate(chr = factor(x =  chr, levels = chr_list),
               RT = (RT - min(RT)) / (max(RT) - min(RT))) %>%
        ungroup()
    
    
    #write output
    write_delim(
        x = Reference_RT%>%
            mutate(group=opt$ref_name),
        file = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_reference_replication_timing_',
            opt$binsSize,
            '.tsv'
        ),
        delim = '\t',
        col_names = T
    )
    
    rm('hits')
}

#merge signal and bg and calculate their ratio
signal_smoothed = Replication_state(Samples =signal_smoothed ,
                                    background = backgroud_smoothed,
                                    chr_list = chr_list,cores = opt$cores)

# remove control track
rm('backgroud_smoothed')

#plot profile binning
plot = signal_smoothed %>%
    group_by(index, group) %>%
    summarise(Rep_percentage = mean(Rep)) %>%
    ggplot(aes(Rep_percentage, color = group)) +
    geom_density(aes(y = ..scaled..)) +
    scale_x_continuous(labels = scales::percent) +
    xlab('Percentage of the genome that has been replicated') +
    ylab('density') + coord_cartesian(xlim = c(0, 1))

suppressMessages(ggsave(
    plot,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_percentage_of_replicating_cells.pdf'
    )
))

#matrix for the correlation
signal_smoothed = signal_smoothed %>%
    ungroup() %>%
    arrange(group, newIndex) %>%
    unite(index, c(group, newIndex), sep = ' _ ') %>%
    mutate(index = factor(index, levels = unique(index)))
mat = signal_smoothed %>%
    unite(pos, c(chr, start), sep = ':') %>%
    mutate(Rep = as.numeric(Rep)) %>%
    dplyr::select(pos, index, Rep) %>%
    spread(key = index, value = Rep) %>%
    column_to_rownames('pos') %>%
    filter(complete.cases(.)) %>%
    as.matrix()

#correlation similarity distance
results = 1-as.matrix(dist.binary(t(mat),method = 2,diag = T,upper = T))
basenames = str_remove(colnames(mat), ' _ [0-9]{1,10}$')
Index = colnames(mat)
basename_n = basenames

for (i in 1:length(unique(basename_n))) {
    basename_n[basename_n == unique(basename_n)[i]] = i
}

#write matrix and plot heatmap before filtering
saveRDS(object = results,
        file = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_correlation_per_cell_before_filtering.rds'
        )
)

#prepare color patterns
selcol <- colorRampPalette(brewer.pal(12, "Set3"))
color = colorRampPalette(colors = c("#00204DFF","#233E6CFF","#575C6DFF","#7C7B78FF","#A69D75FF","#D3C164FF","#FFEA46FF"))

color_basebanes = selcol(length(unique(basename_n)))

jpeg(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_plot_per_cell_before_filter.jpg'
    )
)

heatmap.2(
    results,
    trace = "none",
    dendrogram = 'none',
    Colv = F,
    Rowv = F,
    breaks = seq(0, 1, length.out = 101),
    col = color(100),
    density.info =  'density',
    key.title = 'Simple matching coefficient',
    RowSideColors = color_basebanes[as.numeric(basename_n)],
    ColSideColors = color_basebanes[as.numeric(basename_n)],
    labRow = FALSE,
    labCol = FALSE
)

invisible(dev.off())

#filter cells that do not correlate

to_keep = foreach(i = 1:length(unique(basename_n))) %do% {
    sub_mat = results[basename_n == i, basename_n == i]
    diag(sub_mat) = 0
    ! rowQuantiles(x = sub_mat, probs = 0.60,na.rm = T) <= opt$min_correlation
}

to_keep = unlist(to_keep)
results = results[to_keep, to_keep]
basename_n = basename_n[to_keep]
Index = Index[to_keep]

saveRDS(object = results,
        file = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_correlation_per_cell_after_filtering.rds'
        )
)

color_basebanes = selcol(length(unique(basename_n)))

jpeg(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_plot_per_cell_after_filter.jpg'
    )
)

heatmap.2(
    results,
    trace = "none",
    dendrogram = 'none',
    Colv = F,
    Rowv = F,
    breaks = seq(0, 1, length.out = 101),
    col = color(100),
    density.info =  'density',
    key.title = 'Simple matching coefficient',
    RowSideColors = color_basebanes[as.numeric(basename_n)],
    ColSideColors = color_basebanes[as.numeric(basename_n)],
    labRow = FALSE,
    labCol = FALSE
)

invisible(dev.off())

#filter out samples that don't correlate ans save
signal_smoothed = signal_smoothed %>%
    filter(index %in% Index) %>%
    separate(index, c('group', 'index'), sep = ' _ ') %>% 
    mutate(group = factor(group, level = unique(opt$groups)))

rep_percentage = signal_smoothed %>%
    group_by(Cell,basename,group, index) %>%
    summarise(Rep_percentage = mean(Rep))

plot = rep_percentage %>%
    ggplot(aes(Rep_percentage, color = group)) +
    geom_density(aes(y = ..scaled..)) +
    scale_x_continuous(labels = scales::percent) +
    xlab('Percentage of the genome that has been replicated') +
    ylab('density') + coord_cartesian(xlim = c(0, 1))

suppressMessages(ggsave(
    plot = plot,
    filename = paste0(
        opt$out,
        opt$output_file_base_name,
        '_percentage_of_replicating_cells_after_filtering.pdf'
    )
))

#new index
new_index_list = rep_percentage %>%
    ungroup() %>%
    arrange(Rep_percentage) %>%
    group_by(group) %>%
    mutate(newIndex = 1:n()) %>%
    arrange(group,newIndex) %>%
    dplyr::select(oldIndex=index, newIndex,Cell,basename,group)

signal_smoothed = signal_smoothed %>%
    ungroup() %>%
    inner_join(new_index_list, by = c('Cell','index'='oldIndex', 'basename','group')) %>% 
    dplyr::select(chr,
                  start,
                  end,
                  CN,
                  background,
                  CN_bg,
                  th,
                  Rep,
                  PercentageReplication,
                  Cell,
                  basename,
                  group,
                  newIndex)

write_delim(
    x = signal_smoothed,
    file = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_single_cells_CNV_',
        opt$binsSize,
        '.tsv'
    ),
    delim = '\t',
    col_names = T
)

#select used data and save the new per cell files
used_cells=  rbind( new_index_list%>%
                        dplyr::select(Cell,basename,group )%>%ungroup(),
                    data%>%
                        filter(Type == 'G1/G2-phase cells')%>%
                        dplyr::select(Cell,basename,group )%>%
                        ungroup())

data=data%>%inner_join(used_cells,Joining, by = c("Cell", "basename", "group"))
system(paste0('mkdir -p ', opt$out, '/Cells_used_in_the_analysis_info'))

bs=foreach(i=unique(data$basename))%do%{
    data%>%
        filter(basename==i)%>%
        dplyr::select(Cell,normalized_dimapd,mean_ploidy,ploidy_confidence,is_high_dimapd,is_noisy,coverage_per_1Mbp)%>%
        write_csv(paste0(opt$out, '/Cells_used_in_the_analysis_info/',i,'_per_Cell_summary_metrics.csv'))
    i
    
}

rm('bs')
rm('new_index_list')

#calculate replication timing normalizing each bin by the number of cells in each bin and then calculating the average of the average
# select symmetrically distributed cells.
if (!opt$disable_symmetry){
    
    rep_percentage = rep_percentage%>%
        group_by(group)%>%
        mutate(min_perc=1-max(Rep_percentage),
               max_perc=1-min(Rep_percentage))%>%
        filter(Rep_percentage >= round(min_perc,2),
               Rep_percentage <= round(max_perc,2))%>%
        mutate(min_perc=1-max(Rep_percentage),
               max_perc=1-min(Rep_percentage))%>%
        filter(Rep_percentage >= round(min_perc,2),
               Rep_percentage <= round(max_perc,2))
}

plot = rep_percentage %>%
    ggplot(aes(Rep_percentage, color = group)) +
    geom_density(aes(y = ..scaled..)) +
    scale_x_continuous(labels = scales::percent) +
    xlab('Percentage of the genome that has been replicated') +
    ylab('density') + coord_cartesian(xlim = c(0, 1))

suppressMessages(ggsave(
    plot = plot,
    filename = paste0(
        opt$out,
        opt$output_file_base_name,
        '_percentage_of_replicating_cells_used_for_RT_calculation.pdf'
    )
))

# bin the cells based on their percentage of replication in order have continuous bins with at least one cell.

RT_binning = foreach(Group = unique(rep_percentage$group), .combine = 'rbind') %:%
    foreach(bins = 1:10, .combine = 'rbind') %do% {
        rep_group = rep_percentage %>%
            ungroup() %>%
            filter(group == Group) %>%
            mutate(rep_group = ceiling(100 * Rep_percentage / bins)) %>%
            arrange(rep_group) %>%
            pull(rep_group) %>%
            unique()
        
        cont_rep_group = min(rep_group):max(rep_group)
        
        if (length(cont_rep_group) == length(rep_group)) {
            if (all(rep_group == cont_rep_group)) {
                tibble(group = Group,
                       Binning_step = bins)
            } else{
                tibble()
            }
        } else{
            tibble()
            
        }
    }

RT_binning=RT_binning%>%
    group_by(group)%>%
    summarise(Binning_step=min(Binning_step))

if (!opt$disable_symmetry){
    
    scRT =signal_smoothed%>%
        group_by(group)%>%
        mutate(min_perc=1-max(PercentageReplication),
               max_perc=1-min(PercentageReplication)) %>%
        filter(PercentageReplication >= min_perc,
               PercentageReplication <= max_perc)%>%
        mutate(min_perc=1-max(PercentageReplication),
               max_perc=1-min(PercentageReplication)) %>%
        filter(PercentageReplication >= min_perc,
               PercentageReplication <= max_perc)
}else{
    scRT =signal_smoothed%>%
        group_by(group)
}

scRT=scRT%>%
    inner_join(RT_binning, by = "group")%>%
    mutate(RepGroup=(ceiling(100*PercentageReplication/Binning_step)))%>%
    group_by(chr, start, end, RepGroup, group) %>%
    summarise(Rep = mean(Rep))%>%
    ungroup() %>%
    group_by(chr, start, end, group) %>%
    summarise(RT = mean(Rep)) %>%
    group_by(group) %>%
    mutate(RT = (RT - min(RT)) / (max(RT) - min(RT)))%>%
    dplyr::select(chr,start,end,RT,group)

write_delim(
    x = scRT,
    file = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_calculated_replication_timing_',
        opt$binsSize,
        '.tsv'
    ),
    delim = '\t',
    col_names = T
)

#plots
if (opt$plot) {
    system(paste0('mkdir -p ', opt$out, '/regions'))
    if (!'region' %in% names(opt)) {
        for (i in 1:length(Chr_Size$chr)) {
            region = round(runif(1, min = 1000000, max = 0.8 * Chr_Size$size[i]),
                           0)
            Chr = Chr_Size$chr[i]
            Start = region
            End = region + round(0.2 * Chr_Size$size[i])
            
            # prepare name file
            name_reg = min(str_length(str_extract(Start, '0{1,10}$')),
                           str_length(str_extract(End, '0{1,10}$')))
            name_reg = paste(
                Chr,
                case_when(
                    is.na(name_reg) ~ paste0(Start, 'bp_', End, 'bp'),
                    name_reg < 3 ~ paste0(Start, 'bp_', End, 'bp'),
                    name_reg < 6 ~ paste0(Start / 10 ^ 3, 'Kb_', End / 10 ^
                                              3, 'Kb'),
                    name_reg >= 6 ~ paste0(Start / 10 ^ 6, 'Mb_', End /
                                               10 ^ 6, 'Mb')
                )
            )
            
            
            track_toplot = signal_smoothed %>%
                filter(
                    chr %in% Chr,
                    (start >= Start & end <= End) |
                        (start <= Start & end >= Start) |
                        (start <= End & end >= End)
                ) %>%
                mutate(
                    start = ifelse(start < Start, Start, start),
                    end = ifelse(end > End , End, end)
                )%>%
                filter(start!=end)
            
            if (length(track_toplot$chr) != 0) {
                max_index = track_toplot %>% pull(newIndex) %>% max()
                
                scRT_toplot = scRT %>%
                    ungroup() %>%
                    filter(
                        chr %in% Chr,
                        (start >= Start & end <= End) |
                            (start <= Start & end >= Start) |
                            (start <= End & end >= End)
                    ) %>%
                    mutate(
                        RT = RT ,
                        start = ifelse(start < Start, Start, start),
                        end = ifelse(end > End , End, end)
                    )%>%
                    filter(start!=end)
                
                plot =  ggplot() +
                    geom_rect(
                        data = track_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = -newIndex,
                            ymax = -newIndex - 1,
                            fill = as.numeric(Rep)
                        )
                    ) + geom_rect(
                        data = scRT_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = 0,
                            ymax = max_index / 20,
                            fill = RT
                        ),
                        inherit.aes = F
                    ) +
                    facet_grid(chr ~ group, scale = 'free') +
                    scale_fill_gradient(
                        low = '#005095',
                        high = '#a7001b',
                        limits = c(0, 1)
                    ) +
                    scale_x_continuous(
                        labels = function(x)
                            paste(x / 1000000, 'Mb', sep = ' ')
                    ) +
                    labs(y = 'S phase progression', fill = "Replication Timing\nBinary Replication Profile\n") +
                    theme(
                        legend.position = 'top',
                        axis.text.x = element_text(angle = 45, hjust = 1)
                    )
                
                if ('referenceRT' %in% names(opt)) {
                    RT_toplot = Reference_RT %>%
                        filter(
                            chr %in% Chr,
                            (start >= Start & end <= End) |
                                (start <= Start & end >= Start) |
                                (start <= End & end >= End)
                        ) %>%
                        mutate(
                            RT = RT ,
                            start = ifelse(start < Start, Start, start),
                            end = ifelse(end > End , End, end)
                        )
                    if (length(RT_toplot$chr) != 0) {
                        plot = plot +
                            geom_rect(
                                data = RT_toplot,
                                aes(
                                    xmin = start,
                                    xmax = end,
                                    ymin = max_index / 20,
                                    ymax = max_index / 10,
                                    fill = RT
                                ),
                                inherit.aes = F
                            )  +
                            scale_y_discrete(
                                limits = c(
                                    0.075 * max_index,
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c(
                                    opt$ref_name,
                                    'RT',
                                    seq(1,  max_index, round(max_index / 20))
                                )
                            )
                    } else{
                        plot = plot +
                            scale_y_discrete(
                                limits = c(
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c('RT',  seq(
                                    1,  max_index, round(max_index / 20)
                                ))
                            )
                    }
                } else{
                    plot = plot +
                        scale_y_discrete(
                            limits = c(max_index / 40, -seq(
                                1, max_index, round(max_index / 20)
                            )),
                            labels = c('RT',  seq(
                                1,  max_index, round(max_index / 20)
                            ))
                        )
                }
                
                suppressMessages(ggsave(
                    plot,
                    filename = paste0(
                        opt$out,
                        '/regions/',
                        opt$output_file_base_name,
                        '_plot_RT_',
                        name_reg,
                        '.pdf'
                    )
                ))
            }
        }
    } else{
        if (file.exists(opt$region)) {
            #load bed file if exist
            opt$region = read_tsv(opt$region, col_names = c('chr', 'start', 'end'), col_types = cols(chr='c')) %>%
                mutate(
                    n_0_start = str_length(str_extract(start, '0{1,10}$')),
                    n_0_end = str_length(str_extract(end, '0{1,10}$')),
                    unit = min(
                        factor(
                            case_when(
                                is.na(n_0_start) ~ 'bp',
                                n_0_start < 3 ~ 'bp',
                                n_0_start < 6 ~ 'Kb',
                                n_0_start >= 6 ~ 'Mp'
                            ),
                            levels = c('bp', 'Kb', 'Mp'),
                            ordered = TRUE
                        ),
                        factor(
                            case_when(
                                is.na(n_0_end) ~ 'bp',
                                n_0_end < 3 ~ 'bp',
                                n_0_end < 6 ~ 'Kb',
                                n_0_end >= 6 ~ 'Mp'
                            ),
                            levels = c('bp', 'Kb', 'Mp'),
                            ordered = TRUE
                        )
                    ),
                    name_reg = paste(
                        chr,
                        case_when(
                            unit == 'bp' ~ paste0(start, unit, '_', end, unit),
                            unit == 'Kb' ~ paste0(start / 10 ^ 3, unit, '_', end /
                                                      10 ^ 3, unit),
                            unit == 'Mb' ~ paste0(start / 10 ^ 6, unit, '_', end /
                                                      10 ^ 6, unit)
                        ),
                        sep = '_'
                    )
                ) %>%
                dplyr::select(-unit, -n_0_start, -n_0_end)
        } else{
            #reshape regions
            opt$region = tibble(coord = str_split(opt$region, pattern = ',')[[1]]) %>%
                mutate(name_reg = str_replace_all(
                    coord,
                    pattern = '[-:]',
                    replacement = '_'
                )) %>%
                separate(coord, c('chr', 'pos'), ':') %>%
                separate(pos, c('start', 'end'), '-') %>%
                mutate(
                    start_unit = ifelse(str_count(start)>2, str_extract(start, pattern = '.{2}$'),'bp'),
                    start = as.numeric(str_remove(
                        start, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]"
                    )) * case_when(
                        grepl(x = start_unit, pattern =  '[Kk][Bb]') ~ 1000,
                        grepl(x = start_unit, pattern = '[Mm][Bb]') ~ 1000000,
                        grepl(x = start_unit, pattern = '[Bb][Pp]') ~ 1,
                        grepl(x = start_unit, pattern =  '[0-9][0-9]') ~ 1
                    ),
                    end_unit = ifelse(str_count(end)>2,str_extract(end, pattern = '.{2}$'),'bp'),
                    
                    end = as.numeric(str_remove(
                        end, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]"
                    )) * case_when(
                        grepl(x = end_unit, pattern =  '[Kk][Bb]') ~ 1000,
                        grepl(x = end_unit, pattern = '[Mm][Bb]') ~ 1000000,
                        grepl(x = end_unit, pattern = '[Bb][Pp]') ~ 1,
                        grepl(x = end_unit, pattern =  '[0-9][0-9]') ~ 1
                    )
                ) %>%
                dplyr::select(-start_unit, -end_unit)
        }
        
        
        for (i in 1:length(opt$region$chr)) {
            Chr = opt$region$chr[i]
            Start = opt$region$start[i]
            End = opt$region$end[i]
            
            track_toplot = signal_smoothed %>%
                filter(
                    chr %in% Chr,
                    (start >= Start & end <= End) |
                        (start <= Start & end >= Start) |
                        (start <= End & end >= End)
                ) %>%
                mutate(
                    start = ifelse(start < Start, Start, start),
                    end = ifelse(end > End , End, end)
                )
            
            if (length(track_toplot$chr) != 0) {
                max_index = track_toplot %>% pull(newIndex) %>% max()
                
                scRT_toplot = scRT %>%
                    ungroup() %>%
                    filter(
                        chr %in% Chr,
                        (start >= Start & end <= End) |
                            (start <= Start & end >= Start) |
                            (start <= End & end >= End)
                    ) %>%
                    mutate(
                        RT = RT,
                        start = ifelse(start < Start, Start, start),
                        end = ifelse(end > End , End, end)
                    )
                
                plot =  ggplot() +
                    geom_rect(
                        data = track_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = -newIndex,
                            ymax = -newIndex - 1,
                            fill = as.numeric(Rep)
                        )
                    ) + geom_rect(
                        data = scRT_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = 0,
                            ymax = max_index / 20,
                            fill = RT
                        ),
                        inherit.aes = F
                    ) +
                    facet_grid(chr ~ group, scale = 'free') +
                    scale_fill_gradient(
                        low = '#005095',
                        high = '#a7001b',
                        limits = c(0, 1)
                    ) +
                    scale_x_continuous(
                        labels = function(x)
                            paste(x / 1000000, 'Mb', sep = ' ')
                    ) +
                    labs(y = 'S phase progression', fill = "RT") +
                    theme(
                        legend.position = 'top',
                        axis.text.x = element_text(angle = 45, hjust = 1)
                    )
                
                
                if ('referenceRT' %in% names(opt)) {
                    RT_toplot = Reference_RT %>%
                        filter(
                            chr %in% Chr,
                            (start >= Start & end <= End) |
                                (start <= Start & end >= Start) |
                                (start <= End & end >= End)
                        ) %>%
                        mutate(
                            RT = RT ,
                            start = ifelse(start < Start, Start, start),
                            end = ifelse(end > End , End, end)
                        )%>%
                        filter(start!=end)
                    
                    if (length(RT_toplot$chr) != 0) {
                        plot = plot +
                            geom_rect(
                                data = RT_toplot,
                                aes(
                                    xmin = start,
                                    xmax = end,
                                    ymin = max_index / 20,
                                    ymax = max_index / 10,
                                    fill = RT
                                ),
                                inherit.aes = F
                            ) +
                            scale_y_discrete(
                                limits = c(
                                    0.075 * max_index,
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c(
                                    opt$ref_name,
                                    'RT',
                                    seq(1,  max_index, round(max_index / 20))
                                )
                            )
                    } else{
                        plot = plot +
                            scale_y_discrete(
                                limits = c(
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c('RT',  seq(
                                    1,  max_index, round(max_index / 20)
                                ))
                            )
                    }
                } else{
                    plot = plot +
                        scale_y_discrete(
                            limits = c(max_index / 40, -seq(
                                1, max_index, round(max_index / 20)
                            )),
                            labels = c('RT',  seq(
                                1,  max_index, round(max_index / 20)
                            ))
                        )
                }
                plot = plot + facet_wrap(~ group)
                suppressMessages(ggsave(
                    plot,
                    filename = paste0(
                        opt$out,
                        '/regions/',
                        opt$output_file_base_name,
                        '_plot_RT_',
                        opt$region$name_reg,
                        '.pdf'
                    )
                ))
            }
        }
    }
}

##### RT distributions
if ('referenceRT' %in% names(opt)) {
    RTs = rbind(
        scRT %>%
            ungroup() ,
        
        Reference_RT %>%
            mutate(
                RT = RT / max(RT, na.rm = T),
                group = opt$ref_name
            )
    )
    
    
} else{
    RTs =  scRT 
    
}

pdf(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name
        ,
        '_RT_distribution_plot.pdf'
    )
)

RTs %>%
    ggplot(aes(RT, fill = group)) + geom_density(alpha = 0.2, aes(y = ..count.. /
                                                                      sum(..count..))) +
    xlab('RT') + ylab('density')

invisible(dev.off())


##### Correlation Calculated RT and reference

if (length(unique(RTs$group)) != 1) {
    
    RTs = RTs%>%
        spread(key = group, value = RT) %>%
        filter(complete.cases(.))%>%
        dplyr::select(-chr,-start,-end)
    
    plot = ggcorrplot(
        RTs %>%
            cor(method = 'spearman'),
        lab = T,
        lab_col = 'red',
        legend.title = 'Spearman\ncorrelation',
        colors =  c('#BCAF6FFF', '#7C7B78FF', '#00204DFF'),
        ggtheme = ggplot2::theme(aspect.ratio = 1)
    )
    
    suppressMessages( ggsave(
        plot = plot,
        filename =paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_correlation_plot_RTs.pdf'
        )
    ))
    
    suppressMessages( ggsave(
        plot = ggpairs(RTs,
                       diag = list(continuous =function(data, mapping, ...){
                           p <- ggplot(data,mapping)+
                               geom_density(aes(y=..density../max(..density..)),
                                            fill='grey')+
                               scale_x_continuous(breaks = c(0,0.5,1))+
                               scale_y_continuous(breaks = c(0,0.5,1))
                           return(p)
                       }),
                       upper = list(continuous =function(data, mapping, ...){
                           Spearman=cor(data[as_label(mapping$x)],data[as_label(mapping$y)],method = 'spearman')
                           data=tibble(
                               x=seq(0,2*pi,length.out = 200),
                               Corr=Spearman
                           )%>%
                               mutate(y=0.5+Corr/2*sin(x),
                                      x=0.5+Corr/2*cos(x))
                           
                           p <- ggplot(data, aes(x = x, y = y, fill = Corr))+
                               geom_polygon() + theme(
                                   axis.title = element_blank(),
                                   panel.grid = element_blank()
                               ) +
                               annotate('text',x = 0.5,
                                        y = 0.5,
                                        label = paste("Corr:", round(unique(Spearman), 3), sep = '\n'),
                                        color = 'red') +
                               scale_fill_gradient2(
                                   low = '#BCAF6FFF',
                                   high = '#00204DFF',
                                   mid = '#7C7B78FF',
                                   midpoint = 0,
                                   limits = c(-1, 1)
                               ) + coord_cartesian(xlim = c(0,1), ylim = c(0,1))
                           
                           return(p)
                       }),
                       lower = list(continuous =function(data, mapping, ...){
                           p <- ggplot(data = data, mapping = mapping) + 
                               geom_hex(bins=50,aes(fill=..ndensity..))+
                               scale_fill_gradientn('Density',colours =c("#FFEA46FF","#D3C164FF","#A69D75FF","#7C7B78FF","#575C6DFF","#233E6CFF","#00204DFF"))+
                               coord_cartesian(xlim = c(0,1),ylim = c(0,1))+
                               scale_x_continuous(breaks = c(0,0.5,1))+
                               scale_y_continuous(breaks = c(0,0.5,1))+
                               geom_abline(slope = 1,color='black',alpha=0.5)
                           
                           return(p)
                       }),legend = c(2,1))+ theme(legend.position = "right",
                                                  axis.text.x = element_text(angle = 45,hjust = 1)),
        filename =paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_paired_density_plot_RTs.pdf'
        )
    ))
    
}

#joing RTs with relative signals
signal_smoothed = signal_smoothed %>%
    dplyr::select(group, chr, start, end, Rep,PercentageReplication) %>%
    inner_join(scRT, by = c("group", "chr", "start", "end"))  %>%
    mutate(
        RT = 10 * (1-RT) ,
        time = round( RT - 10*PercentageReplication,1)
    )


#test multiple time windows
cl <- makeCluster(opt$cores)
registerDoSNOW(cl)

x = signal_smoothed%>%
    group_by(group,time,RT,chr,start,end)%>%
    summarise(percentage=mean(Rep))


x %>%
    ungroup()%>%
    dplyr::select(-RT)%>%
    write_tsv(
        paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_scRT_variability.tsv'
        )
    )

# function to assign categories
split_into_categoreis=Vectorize(function(RT,number){
    if(number==3){
        return( case_when(
            RT < 3 ~ '1 - Early',
            RT >= 3 & RT < 6 ~ '2 - Mid',
            RT >= 6  ~ '3 - Late'
        ))
    }else if (number==5){
        return( case_when(
            RT < 2 ~ '1 - Very Early',
            RT >= 2 & RT < 4  ~ '2 - Early',
            RT >= 4 & RT < 6 ~ '3 - Mid',
            RT >= 6 & RT < 8 ~ '4 - Late',
            RT >= 8  ~ '5 - Very Late'))
    }else {
        return( case_when(
            RT < 5 ~ '1 - Early',
            RT >= 5  ~ '2 - Late'
        ))
    }
},vectorize.args = 'RT' )
cat_levels=function(number){
    if(number==3){
        return( c(
            '0 - All',
            '1 - Early',
            '2 - Mid',
            '3 - Late'
        ))
    }else if (number==5){
        return( c(
            '0 - All',
            '1 - Very Early',
            '2 - Early',
            '3 - Mid',
            '4 - Late',
            '5 - Very Late'
        ))
    }else {
        return( c(
            '0 - All',
            '1 - Early',
            '2 - Late'
        )
        )
    }
}

x = rbind(x  %>%
              mutate(
                  Cat_RT = split_into_categoreis(RT,number = opt$N_of_RT_groups),
                  Cat_RT = factor(
                      Cat_RT,
                      levels = cat_levels( opt$N_of_RT_groups)
                  )
              ),
          x%>%
              mutate(
                  Cat_RT = '0 - All',
                  Cat_RT = factor(
                      Cat_RT,
                      levels = cat_levels( opt$N_of_RT_groups)
                  )
              ))


x=x%>%
    group_by(group,time,Cat_RT)%>%
    summarise(percentage=mean(percentage))%>%
    ungroup()

#T25_75 function
T25_75 = function(df, name, EL) {
    model = tryCatch(
        nls(percentage ~ SSlogis(time, Asym, xmid, scal),
            data = df[, c('percentage', 'time')]%>%
                add_row(percentage=1,time=-10)%>%
                add_row(percentage=0,time=10),
            control = nls.control(maxiter = 100),
            algorithm = 'port',
            start = c(Asym=1,xmid=0,scal=-0.5)
        ),
        #If the data cannot be fitted with a Gauss-Newton algorithm, try the
        #Golub and Pereyra algorithm for the solution of a nonlinear least squares
        #problem which assumes a number of the parameters are linear.
        #Also, add a higher tolerance (1e-04 Vs 1e-05).
        error = tryCatch(function(e)
            nls(
                percentage ~ SSlogis(time, Asym, xmid, scal),
                data = df[, c('percentage', 'time')]%>%
                    add_row(percentage=1,time=-10)%>%
                    add_row(percentage=0,time=10),
                algorithm = 'plinear',
                control = nls.control(maxiter = 100,tol = 1e-04, warnOnly = T)
            ),
            error = function(e) print('Try to reduce the number of RT groups') 
        )
    )
    min = min(df$time)
    max = max(df$time)
    data = predict(model,
                   newdata = data.frame(time = seq(min, max, 0.01)),
                   type = "l")
    result = data.frame(
        time = seq(min, max, 0.01),
        percentage = data,
        group = name
    )
    t = result %>%
        mutate(
            distance75 = abs(percentage - 0.75),
            distance25 = abs(percentage - 0.25)
        ) %>%
        mutate(
            min75 = min(distance75),
            min25 = min(distance25),
            t75 = distance75 == min75,
            t25 = distance25 == min25
        ) %>%
        dplyr::select(group, time, percentage, t75, t25)  %>%
        mutate(Cat_RT = EL)
    
    return(t)
}

#calculate thresholds 25% 75% replication keeping in account early and late domains
fitted_data = foreach(
    group = unique(x$group),
    .combine = 'rbind',
    .packages = c('tidyverse', 'foreach'),
    .errorhandling = 'remove'
) %do% {
    temp = foreach(
        EL = unique(x$Cat_RT),
        .combine = 'rbind',
        .packages = c('tidyverse', 'foreach'),
        .errorhandling = 'remove'
    ) %dopar% {
        t = T25_75(df = x[x$group == group &
                              x$Cat_RT == EL, ], group, EL)
    }
    temp
}

t = fitted_data %>% filter(t75 | t25) %>%
    gather('t', 'value', t25, t75) %>%
    filter(value) %>%
    dplyr::select(-percentage, -value) %>%
    spread(t, time) %>%
    mutate(Twidth = abs(t75 - t25))

t %>% write_tsv(paste0(opt$out,
                       '/',
                       opt$output_file_base_name,
                       '_Twidth.tsv'))


plot=ggplot(x) +
    geom_point(aes(time,percentage,color=group))+
    geom_line(data=fitted_data,aes(time,percentage),color='blue')+
    scale_x_reverse()+scale_y_continuous(labels = scales::percent)+
    geom_vline(data=t,aes(xintercept=t25),color='red')+
    geom_vline(data=t,aes(xintercept=t75),color='red')+
    geom_text(data=t,aes(label=paste('TW\n',Twidth)),x=Inf,y=0.5, hjust=1.25)+
    facet_grid(group~Cat_RT)

ncat=length(unique(x$Cat_RT))
nbasen=length(unique(x$group))
suppressMessages(ggsave(
    plot,
    filename = paste0(opt$out,
                      '/',
                      opt$output_file_base_name,
                      '_Twidths_extended.pdf'),width = 2.5*ncat,height = 4*nbasen
))


p = ggplot(t) +
    geom_col(aes(Cat_RT, Twidth, fill = group), position = 'dodge') +
    ylab('Twidth') + xlab('')

suppressMessages(ggsave(
    p,
    filename = paste0(opt$out,
                      '/',
                      opt$output_file_base_name,
                      '_Twidths.pdf')
))

if (opt$Var_against_reference) {
    #joing reference with relative signals
    signal_smoothed = signal_smoothed %>%
        dplyr::select(group, chr, start, end, Rep,PercentageReplication) %>%
        inner_join(Reference_RT, by = c("chr", "start", "end"))  %>%
        mutate(
            RT = 10 * (1-RT) ,
            time = round(RT - 10*PercentageReplication,1)
        )
    
    
    x = signal_smoothed%>%
        group_by(group,time,RT,chr,start,end)%>%
        summarise(percentage=mean(Rep))
    
    
    x %>%
        ungroup()%>%
        dplyr::select(-RT)%>%
        write_tsv(
            paste0(
                opt$out,
                '/',
                opt$output_file_base_name,
                '_scRT_variability_on_reference.tsv'
            )
        )
    
    x = rbind(x  %>%
                  mutate(
                      Cat_RT = split_into_categoreis(RT,number = opt$N_of_RT_groups),
                      Cat_RT = factor(
                          Cat_RT,
                          levels = cat_levels( opt$N_of_RT_groups)
                      )
                  ),
              x%>%
                  mutate(
                      Cat_RT = '0 - All',
                      Cat_RT = factor(
                          Cat_RT,
                          levels = cat_levels( opt$N_of_RT_groups)
                      )
                  ))
    
    x=x%>%
        group_by(group,time,Cat_RT)%>%
        summarise(percentage=mean(percentage)) 
    
    #calculate thresholds 25% 75% replication keeping in account early and late domains  ##WHY IS THIS REPEATED ??
    fitted_data = foreach(
        group = unique(x$group),
        .combine = 'rbind',
        .packages = c('tidyverse', 'foreach'),
        .errorhandling = 'remove'
    ) %do% {
        temp = foreach(
            EL = unique(x$Cat_RT),
            .combine = 'rbind',
            .packages = c('tidyverse', 'foreach'),
            .errorhandling = 'remove'
        ) %dopar% {
            t = T25_75(df = x[x$group == group &
                                  x$Cat_RT == EL, ], group, EL)
        }
        temp
    }
    
    t = fitted_data %>% filter(t75 | t25) %>%
        gather('t', 'value', t25, t75) %>%
        filter(value) %>%
        dplyr::select(-percentage, -value) %>%
        spread(t, time) %>%
        mutate(Twidth = abs(t75 - t25))
    
    t %>% write_tsv(paste0(opt$out,
                           '/',
                           opt$output_file_base_name,
                           '_Twidth_ref_RT.tsv'))
    
    
    plot=ggplot(x) +
        geom_point(aes(time,percentage,color=group))+
        geom_line(data=fitted_data,aes(time,percentage),color='blue')+
        scale_x_reverse()+scale_y_continuous(labels = scales::percent)+
        geom_vline(data=t,aes(xintercept=t25),color='red')+
        geom_vline(data=t,aes(xintercept=t75),color='red')+
        geom_text(data=t,aes(label=paste('TW\n',Twidth)),x=Inf,y=0.5, hjust=1.25)+
        facet_grid(group~Cat_RT)
    
    ncat=length(unique(x$Cat_RT))
    nbasen=length(unique(x$group))
    suppressMessages(ggsave(
        plot,
        filename = paste0(opt$out,
                          '/',
                          opt$output_file_base_name,
                          '_Twidths_extended_ref_RT.pdf'),width = 2.2*ncat,height = 4*nbasen
    ))
    
    p = ggplot(t) +
        geom_col(aes(Cat_RT, Twidth, fill = group), position = 'dodge') +
        ylab('Twidth') + xlab('')
    
    suppressMessages(ggsave(
        p,
        filename = paste0(opt$out,
                          '/',
                          opt$output_file_base_name,
                          '_Twidths_ref_RT.pdf')
    ))
    
}

stopCluster(cl)


print('done')

