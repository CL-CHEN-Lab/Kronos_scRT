#!/usr/local/bin/Rscript --slave
#parse input
suppressPackageStartupMessages(library(optparse, quietly = TRUE))

options(stringsAsFactors = FALSE)
options(warn = 1, scipen = 999)

option_list = list(
    make_option(
        c("-K", "--Kronos_conf_file"),
        type = "character",
        default = NULL,
        help = "Kronos setting file. If provided -F,-T,-S,-b and -g are ignored. Tab file containing: Per cell stat file <TAB> tracks file <TAB> settings file <TAB> basename (optional) <TAB> group (optional) ",
        metavar = "character"
    ),make_option(
        c("-F", "--file"),
        type = "character",
        default = NULL,
        help = "Per cell stat file , if multiple files are provided they have to be separated by a comma",
        metavar = "character"
    ),
    make_option(
        c("-T", "--tracks"),
        type = "character",
        default = NULL,
        help = "Tracks file,  if multiple files are provided they have to be separated by a comma",
        metavar = "character"
    ),
    make_option(
        c("-R", "--referenceRT"),
        type = "character",
        default = NULL,
        help = "Reference RT min=Late, max=Early, only one reference is allowed",
        metavar = "character"
    ),
    make_option(
        c("--ref_name"),
        type = "character",
        default = "Reference",
        help = "Name for the reference track [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-C", "--chrSizes"),
        type = "character",
        default = NULL,
        help = "Chromosome size file",
        metavar = "character"
    ),
    make_option(
        c("-r", "--region"),
        type = "character",
        default = NULL,
        help = "Region to plot  chr:start-end (multiple regins can be separated by a comma) or provided as a bed file",
        metavar = "character"
    ),
    make_option(
        c("-o", "--out"),
        type = "character",
        default = "output",
        help = "Output directory [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-b", "--base_name"),
        type = "character",
        default = "exp",
        help = "Base name for files names [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-f", "--output_file_base_name"),
        type = "character",
        default = "out",
        help = "Base name for the output file [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-g", "--groups"),
        type = "character",
        help = "Grouping names of multiple basenames [default= base_name]",
        metavar = "character"
    ),
    make_option(
        c("-S", "--settings_file"),
        type = "character",
        help = "File generated by Kronos diagnostic",
        metavar = "character"
    ),
    make_option(
        c("-B", "--binsSize"),
        type = "character",
        default = '500Kb',
        help = "RT resolution (supports units) [default= %default] ",
        metavar = "character"
    ),
    make_option(
        c("-X", "--keep_X"),
        type = "logical",
        default = FALSE,
        action = "store_true",
        help = "Keep X chromosomes in the analysis",
        metavar = "logical"
    ),
    make_option(
        c("-Y", "--keep_Y"),
        type = "logical",
        default = FALSE,
        action = "store_true",
        help = "Keep Y chromosomes in the analysis",
        metavar = "logical"
    ),
    make_option(
        c("-c", "--cores"),
        type = "integer",
        default = 3,
        help = "Numbers of parallel jobs to run [default= %default]",
        metavar = "integer"
    ),
    make_option(
        c("-N", "--N_of_RT_groups"),
        type = "integer",
        default = 2,
        help = "Number of RT groups: either 2,3 or 5 [default= %default]",
        metavar = "integer"
    ),
    make_option(
        c("-p", "--plot"),
        type = "logical",
        default = F,
        action = "store_true",
        help = "If selected prints some randome regins, if -r is selected those regins are use to print RT [default= %default] ",
        metavar = "logical"
    ),
    make_option(
        c("--Var_against_reference"),
        type = "logical",
        default = F,
        action = "store_true",
        help = "Variability metrics are calculated usign reference RT in addiction to the calculated one [default= %default] ",
        metavar = "logical"
    ),
    make_option(
        c("--min_correlation"),
        type = "double",
        default = 0.25,
        help = "Minimum correlation value between one cell and its best correlating cell for this cell to not be discarded [default= %default] ",
        metavar = "double"
    )
)

#recover inputs
opt = parse_args(object = OptionParser(option_list = option_list))

#load libraries
suppressPackageStartupMessages(library(tidyverse, quietly = TRUE))
suppressPackageStartupMessages(library(GGally, quietly = TRUE))
suppressPackageStartupMessages(library(ggcorrplot, quietly = TRUE))
suppressPackageStartupMessages(library(foreach, quietly = TRUE))
suppressPackageStartupMessages(library(doSNOW, quietly = TRUE))
suppressPackageStartupMessages(library(gplots, quietly = TRUE))
suppressPackageStartupMessages(library(matrixStats, quietly = TRUE))
suppressPackageStartupMessages(library(RColorBrewer, quietly = TRUE))
suppressPackageStartupMessages(library(GenomicRanges, quietly = TRUE))
suppressPackageStartupMessages(library(MASS, quietly = TRUE))

#set plotting theme
theme_set(theme_bw())

#check inputs
if('Kronos_conf_file' %in% names(opt)) {
    
    settings=tryCatch(expr = read_tsv(opt$Kronos_conf_file,col_names = c('file','traks','settings','basename','groups'),col_types = cols())%>%
        mutate(
            basename=ifelse(is.na(basename),paste0('exp',row_number()),basename),
            groups=ifelse(is.na(groups),basename,groups)
        ),
        error=function(e){stop('Settings file does not exitst. See script usage (--help)')},
        warning=function(w){
            tmp=suppressWarnings(
            read_tsv(opt$Kronos_conf_file,col_names = c('file','traks','settings','basename','groups'),col_types = cols())%>%
                mutate(
                    basename=ifelse(is.na(basename),paste0('exp',row_number()),basename),
                    groups=ifelse(is.na(groups),basename,groups)
                ))
            warning('missing basenames and groups were replaced with default parameters')
            return(tmp)})
    
    #reformat files
    opt$file = settings$file
    
    opt$settings_file = settings$settings
    
    opt$tracks = settings$traks
    
    opt$base_name = settings$basename
    
    opt$groups = settings$groups
    
} else{
    
    if (!'file' %in% names(opt)) {
        stop("Per cell stat file or Kronos setting file must be provided. See script usage (--help)")
    }
    
    if (!'tracks' %in% names(opt)) {
        stop("File containing cells CNV or Kronos setting file must be provided. See script usage (--help)")
    }
    
    if (!'settings_file' %in% names(opt)) {
        stop("File containing settings sizes must be provided. See script usage (--help)")
    }
    
    if (!'groups' %in% names(opt)) {
        opt$groups = opt$base_name
    }
    
    #reformat files
    opt$file = str_split(opt$file, ',')[[1]]
    
    opt$settings_file = str_split(opt$settings_file, ',')[[1]]
    
    opt$tracks = str_split(opt$tracks, ',')[[1]]
    
    opt$base_name = str_split(opt$base_name, ',')[[1]]
    
    opt$groups = str_split(opt$groups, ',')[[1]]
    
    
}    

if (!'chrSizes' %in% names(opt)) {
    stop("File containing Chromosomes sizes must be provided. See script usage (--help)")
}

if (opt$Var_against_reference) {
    if (!'referenceRT' %in% names(opt)) {
        warning("Reference genome not provided")
        opt$Var_against_reference = F
    }
}

# convert binsize to numeric
extract_unit = str_extract(opt$binsSize, pattern = '.{2}$')
resolution = as.numeric(str_remove(opt$binsSize, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]")) * case_when(
    grepl(x = extract_unit, pattern =  '[Kk][Bb]') ~ 1000,
    grepl(x = extract_unit, pattern = '[Mm][Bb]') ~ 1000000,
    grepl(x = extract_unit, pattern = '[Bp][Pp]') ~ 1,
    grepl(x = extract_unit, pattern =  '[0-9][0-9]') ~ 1
)

if (any(is.na(resolution))) {
    stop('binsize have an incorrect format')
}

# prepare name file
if (grepl(x = extract_unit, pattern =  '[0-9][0-9]')) {
    n_of_zeros = str_length(str_extract(opt$binsSize, '0{1,10}$'))
    opt$binsSize = case_when(
        is.na(n_of_zeros) ~ paste0(opt$binsSize, 'bp'),
        n_of_zeros < 3 ~ paste0(opt$binsSize, 'bp'),
        n_of_zeros < 6 ~ paste0(str_remove(opt$binsSize, '0{3}$'), 'Kb'),
        n_of_zeros >= 6 ~ paste0(str_remove(opt$binsSize, '0{6}$'), 'Mp')
    )
} else{
    opt$binsSize = opt$binsSize
}

#create directory
if (str_extract(opt$out, '.$') != '/') {
    opt$out = paste0(opt$out, '/')
}

system(paste0('mkdir -p ', opt$out))


# check inputs
if (length(opt$tracks) != length(opt$file)) {
    stop("The number stat files does not match provided trakcs. See script usage (--help)")
}

if (length(opt$base_name) != length(opt$file)) {
    index = rep(
        1:length(opt$file),
        length(opt$file),
        each = length(opt$base_name),
        length.out = length(opt$file)
    )
    opt$base_name = paste(rep_len(opt$base_name, length(opt$file)), index, sep = '-')
    warning('basenames will be cyclicly recicled')
}

if (length(opt$groups) != length(opt$file)) {
    index = rep(
        1:length(opt$file),
        length(opt$file),
        each = length(opt$groups),
        length.out = length(opt$file)
    )
    opt$groups = paste(rep_len(opt$groups, length(opt$groups)), index, sep = '-')
    warning('groups variable will be cyclicly recicled')
}

#load genome sizes
Chr_Size=read_tsv(opt$chrSizes,col_names =c('chr','size'),col_types = cols())%>%
    filter(case_when(
        !opt$keep_X & chr=='chrX' ~ F,
        !opt$keep_Y & chr=='chrY' ~ F,
        T~T
    ))

#chr order
chr_list = paste0('chr', c(1:100, 'X', 'Y'))

chr_list = chr_list[chr_list %in% unique(Chr_Size$chr)]

Chr_Size = Chr_Size %>%
    mutate(chr = factor(x =  chr, levels = chr_list)) %>%
    drop_na()

#load single cells infor
data <-
    foreach(
        i = 1:length(opt$file),
        .combine = 'rbind',
        .packages = 'tidyverse'
    ) %do% {
        inner_join(
            read_csv(opt$file[i], col_types = cols()) %>%
                mutate(
                    basename = factor(opt$base_name[i], levels = opt$base_name),
                    group = factor(opt$groups[i], levels = unique(opt$groups))
                ),
            read_tsv(opt$settings_file[i], col_types = cols()) %>%
                mutate(
                    basename = factor(opt$base_name[i], levels = opt$base_name),
                    group = factor(opt$groups[i], levels = unique(opt$groups))
                ),
            by = c('basename', 'group')
        )
    }

#filter data with too little reads per megabase (0.75milion reads for a diploid human genome)
data = data %>% filter(coverage_per_1Mbp >= RPM_TH)

#load tracks
all_tracks <-
    foreach(
        i = 1:length(opt$tracks),
        .combine = 'rbind',
        .packages = 'tidyverse'
    ) %do% {
        read_delim(opt$tracks[i], delim = '\t', col_types = cols()) %>%
            mutate(
                basename = factor(opt$base_name[i], levels = opt$base_name),
                group = factor(opt$groups[i], levels = unique(opt$groups)),
                chr = factor(x =  chr, levels = chr_list)
            ) %>%
            drop_na()
    }

# remove tracks not in use
CB = data %>%
    dplyr::select(Cell, basename)

all_tracks = all_tracks %>%
    inner_join(CB, by = c("Cell", "basename"))

rm('CB')

if ('referenceRT' %in% names(opt)) {
    Reference_RT <-
        read_delim(
            opt$referenceRT,
            delim = '\t',
            col_names = c('chr', 'start', 'end', 'RT'),
            col_types = cols()
        ) %>%
        mutate(chr = factor(x =  chr, levels = chr_list))
}

# calculate the new is_high_dimapd
data = data %>%
    mutate(
        is_noisy = as.logical(is_noisy),
        is_high_dimapd = ifelse(
            is.na(threshold_Sphase),
            is_high_dimapd,
            ifelse(normalized_dimapd > threshold_Sphase, T, F)
        ),
        is_noisy = ifelse(is_high_dimapd, T, is_noisy)
    )

median_ploidy_G1_G2_cells = data %>%
    filter(ifelse(
        is.na(threshold_G1G2phase),
        is_noisy == F,
        is_noisy == F &
            normalized_dimapd < threshold_G1G2phase
    )) %>%
    group_by(basename) %>%
    summarise(median_ploidy_G1_G2_cells = median(mean_ploidy))

data = data %>%
    inner_join(median_ploidy_G1_G2_cells, by = 'basename') %>%
    filter(
        mean_ploidy > median_ploidy_G1_G2_cells / 1.50 ,
        mean_ploidy < median_ploidy_G1_G2_cells * 2,
        !ploidy_confidence <= 2 | ploidy_confidence == -100
    ) %>%
    mutate(Type = ifelse(
        as.logical(is_high_dimapd) == T &
            as.logical(is_noisy) == T,
        'S-phase',
        ifelse(
            ifelse(
                is.na(threshold_G1G2phase),
                as.logical(is_high_dimapd) == F &
                    as.logical(is_noisy) == F,
                as.logical(is_high_dimapd) == F &
                    as.logical(is_noisy) == F &
                    normalized_dimapd < threshold_G1G2phase
            ),
            'G1/G2 cells',
            'unknown cells'
        )
    ))

#plot Variability vs ploidy
p = data %>%
    ggplot(aes(mean_ploidy,
               normalized_dimapd,
               color = Type)) +
    geom_point(alpha = 0.3) +
    scale_color_manual(
        values = c(
            'G1/G2 cells' = 'darkred',
            'S-phase' = 'darkgreen',
            'unknown cells' = 'darkorange'
        )
    ) +
    theme(legend.position = 'top', legend.title = element_blank()) +
    geom_vline(aes(xintercept = median_ploidy_G1_G2_cells)) + facet_wrap(group ~
                                                                             basename, scales = 'free') +
    xlab('Ploidy') + ylab('Variability')

suppressMessages(ggsave(
    p,
    filename = paste0(opt$out, '/', opt$output_file_base_name, '_plot.pdf')
))

# correct mean ploidy late S phase
data = data %>%
    mutate(
        mean_ploidy_corrected = ifelse(
            as.logical(is_noisy) == T &
                mean_ploidy < median_ploidy_G1_G2_cells,
            mean_ploidy / Sphase_second_part,
            ifelse(
                as.logical(is_noisy) == T &
                    mean_ploidy > median_ploidy_G1_G2_cells,
                mean_ploidy / Sphase_first_part,
                mean_ploidy
            )
        )
    )

#plot Variability vs ploidy (after correction)
p = data %>%
    ggplot(aes(mean_ploidy_corrected, normalized_dimapd, color = Type)) +
    geom_point(alpha = 0.3) +
    scale_color_manual(
        values = c(
            'G1/G2 cells' = 'darkred',
            'S-phase' = 'darkgreen',
            'unknown cells' = 'darkorange'
        )
    ) +
    theme(legend.position = 'top', legend.title = element_blank()) +
    geom_vline(aes(xintercept = median_ploidy_G1_G2_cells)) + facet_wrap(group ~
                                                                             basename, scales = 'free') +
    xlab('Ploidy') + ylab('Variability')

suppressMessages(ggsave(
    p,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_plot_sphase_corrected.pdf'
    )
))

#resolution
cl <- makeCluster(opt$cores)
registerDoSNOW(cl)

bins = foreach(chr = 1:length(Chr_Size$chr),
               .combine = 'rbind') %dopar% {
                   bins = seq(from = resolution,
                              to = Chr_Size$size[chr] ,
                              by =  resolution)
                   bins = data.frame(
                       chr =  factor(x =  Chr_Size$chr[chr], levels = chr_list),
                       start = bins - resolution,
                       end = bins
                   )
                   bins
               }

bins = bins %>%
    makeGRangesFromDataFrame(
        seqnames.field  = 'chr',
        start.field = 'start' ,
        end.field = 'end'
    )


#select Sphase cells
selected_data = data %>%
    filter(Type == 'S-phase') %>%
    arrange(mean_ploidy_corrected) %>%
    mutate(index = 1:n()) %>%
    dplyr::select(index,
                  Cell,
                  mean_ploidy,
                  mean_ploidy_corrected,
                  basename,
                  group)
# select G1/G2 cells
G1_G2_cells = data %>%
    filter(Type == 'G1/G2 cells')

# select tracks of G1/G2 cells
G1_G2_cells_tracks = all_tracks %>%
    inner_join(G1_G2_cells, by = c('Cell', 'basename', 'group')) %>%
    makeGRangesFromDataFrame(
        seqnames.field  = 'chr',
        start.field = 'start' ,
        end.field = 'end',
        keep.extra.columns = T
    )

#select Sphase traks
Sphase_tracks = all_tracks %>%
    inner_join(selected_data, by = c('Cell', 'basename', 'group')) %>%
    mutate(
        copy_number_corrected = ifelse(
            mean_ploidy == mean_ploidy_corrected,
            copy_number,
            copy_number * mean_ploidy_corrected / mean_ploidy
        )
    ) %>%
    makeGRangesFromDataFrame(
        seqnames.field  = 'chr',
        start.field = 'start' ,
        end.field = 'end',
        keep.extra.columns = T
    )

#free some memory
rm('all_tracks')

#calculate median CNV across a bin for S cells

hits = findOverlaps(bins, Sphase_tracks)

overlaps <-
    pintersect(Sphase_tracks[subjectHits(hits)], bins[queryHits(hits)])

signal_smoothed = cbind(
    as_tibble(bins[queryHits(hits)]) %>% dplyr::select(seqnames, start, end) %>%
        `colnames<-`(c('chr', 'start', 'end')),
    as_tibble(overlaps) %>% dplyr::select(-seqnames, -start, -end)
) %>%
    group_by(Cell,index, basename, group, chr, start, end) %>%
    summarise(CN = weightedMedian(x = copy_number_corrected, w =
                                      width, na.rm = T)) %>%
    ungroup()


#free memory
rm('Sphase_tracks')
rm('hits')
rm('overlaps')

#calculate median CNV across a bin across all the G1/G2 cells
hits = findOverlaps(bins, G1_G2_cells_tracks)

overlaps <-
    pintersect(G1_G2_cells_tracks[subjectHits(hits)], bins[queryHits(hits)])

backgroud_smoothed = cbind(
    as_tibble(bins[queryHits(hits)]) %>% dplyr::select(seqnames, start, end) %>%
        `colnames<-`(c('chr', 'start', 'end')),
    as_tibble(overlaps) %>% dplyr::select(-seqnames, -start, -end)
) %>%
    group_by(basename, group, chr, start, end) %>%
    summarise(background = weightedMedian(x = copy_number, w =
                                              width, na.rm = T)) %>%
    ungroup()


#free some space
rm('G1_G2_cells_tracks')
rm('hits')
rm('overlaps')

if ('referenceRT' %in% names(opt)) {
    # rebin reference RT
    Reference_RT = Reference_RT %>%
        drop_na() %>%
        makeGRangesFromDataFrame(
            seqnames.field = 'chr',
            start.field = 'start',
            end.field = 'end',
            keep.extra.columns = T
        )
    
    hits = findOverlaps(bins, Reference_RT)
    
    overlaps <-
        pintersect(Reference_RT[subjectHits(hits)], bins[queryHits(hits)])
    
    Reference_RT = cbind(
        as_tibble(bins[queryHits(hits)]) %>% dplyr::select(seqnames, start, end) %>%
            `colnames<-`(c('chr', 'start', 'end')),
        as_tibble(overlaps) %>% dplyr::select(-seqnames, -start, -end)
    ) %>%
        group_by(chr, start, end) %>%
        summarise(RT = weightedMedian(x = RT, w =
                                          width, na.rm = T)) %>%
        ungroup() %>%
        mutate(chr = factor(x =  chr, levels = chr_list),
               RT = (RT - min(RT)) / (max(RT) - min(RT))) %>%
        ungroup()
    
    
    #write output
    write_delim(
        x = Reference_RT%>%
            mutate(group=opt$ref_name),
        path = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_reference_replication_timing_',
            opt$binsSize,
            '.tsv'
        ),
        delim = '\t',
        col_names = T
    )
    
    rm('hits')
    rm('overlaps')
    
    
}

#merge signal and bg and calculate their ratio
signal_smoothed = signal_smoothed %>%
    ungroup() %>%
    mutate(chr = factor(x =  chr, levels = chr_list)) %>%
    inner_join(backgroud_smoothed,
               by = c("chr", "start", "end", "basename", 'group')) %>%
    mutate(CN_bg = log2(CN / background)) %>%
    drop_na() %>%
    filter(is.finite(CN_bg))

# remove control track
rm('backgroud_smoothed')

# identify threshold that minimazes the difference of the real data with a binary state (1 or 2)
selecte_th = foreach(
    line = unique(signal_smoothed$basename),
    .combine = 'rbind',
    .packages = c('foreach', 'tidyverse')
) %dopar% {
    sub_sig = signal_smoothed %>%
        filter(basename == line)
    
    #identify range within looking for a CNV treshold to define replicated and not replicated values
    range = seq(0, 1, 0.01)
    
    th_temp = foreach(i = range,
                      .combine = 'rbind',
                      .packages = 'tidyverse') %do% {
                          summary = sub_sig %>%
                              mutate(Rep = ifelse(CN_bg >= i, T, F),
                                     Error = (Rep - CN_bg)^2) %>%
                              group_by(Cell,index, basename, group)  %>%
                              summarise(summary = sum(Error))
                          
                          data.frame(
                              th = i,
                              basename = summary$basename,
                              index = summary$index,
                              sum_error = summary$summary
                          )
                      }
    th_temp
}

selecte_th = selecte_th %>%
    group_by(index, basename) %>%
    filter(sum_error == min(sum_error)) %>%
    summarise(th = min(th)) %>%
    ungroup()

# mark replicated bins
signal_smoothed = signal_smoothed %>%
    inner_join(selecte_th, by = c("index", "basename")) %>%
    mutate(Rep = ifelse(CN_bg >= th, T, F))

#identify new distribution in the S phase based the ammount of replicated bins
new_index_list = signal_smoothed %>%
    group_by(Cell,index, basename, group) %>%
    summarise(perc_replication = mean(Rep)) %>%
    ungroup() %>%
    arrange(perc_replication) %>%
    group_by(group) %>%
    mutate(newIndex = 1:n()) %>%
    dplyr::select(oldIndex=index, newIndex,Cell, basename, group)

write_tsv(new_index_list,paste0(
    opt$out,
    '/',
    opt$output_file_base_name,
    '_new_old_index_correspondance_before_filtering'
))

signal_smoothed = signal_smoothed %>%
    inner_join(new_index_list, by = c('Cell','index'='oldIndex', 'basename','group')) 

stopCluster(cl)

# bin cells in order to have not unballance RT
signal_smoothed = signal_smoothed %>%
    group_by(Cell,index, group) %>% 
    mutate(PercentageReplication = mean(Rep))

#plot profile binning
plot = signal_smoothed %>%
    group_by(index, group) %>%
    summarise(Rep_percentage = mean(Rep)) %>%
    ggplot(aes(Rep_percentage, color = group)) +
    geom_density(aes(y = ..scaled..)) +
    scale_x_continuous(labels = scales::percent) +
    xlab('Percentage of the genome that has been replicated') +
    ylab('density') + coord_cartesian(xlim = c(0, 1))

suppressMessages(ggsave(
    plot,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_percentage_of_replicating_cells.pdf'
    )
))

#matrix for the correlation
signal_smoothed = signal_smoothed %>%
    ungroup() %>%
    arrange(group, newIndex) %>%
    unite(index, c(group, newIndex), sep = ' _ ') %>%
    mutate(index = factor(index, levels = unique(index)))
mat = signal_smoothed %>%
    unite(pos, c(chr, start), sep = ':') %>%
    mutate(Rep = as.numeric(Rep)) %>%
    dplyr::select(pos, index, Rep) %>%
    spread(key = index, value = Rep) %>%
    column_to_rownames('pos') %>%
    filter(complete.cases(.)) %>%
    as.matrix()

#correlation
results = cor(mat, mat)
basenames = str_remove(colnames(mat), ' _ [0-9]{1,10}$')
Index = colnames(mat)
basename_n = basenames

for (i in 1:length(unique(basename_n))) {
    basename_n[basename_n == unique(basename_n)[i]] = i
}

#write matrix and plot heatmap before filtering
write.matrix(
    x = results,
    file = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_per_cell_before_filtering.mx'
    ),
    sep = '\t'
)

#prepare color patterns
selcol <- colorRampPalette(brewer.pal(12, "Set3"))
color = colorRampPalette(colors = c('blue', 'green', 'yellow', 'orange', 'red'))

color_basebanes = selcol(length(unique(basename_n)))

jpeg(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_plot_per_cell_before_filter.jpg'
    )
)

heatmap.2(
    results,
    trace = "none",
    dendrogram = 'none',
    Colv = F,
    Rowv = F,
    breaks = seq(0, 1, length.out = 101),
    col = color(100),
    density.info =  'density',
    key.title = 'Pearson',
    RowSideColors = color_basebanes[as.numeric(basename_n)],
    ColSideColors = color_basebanes[as.numeric(basename_n)],
    labRow = FALSE,
    labCol = FALSE
)

invisible(dev.off())

#filter cells that do not correlate

to_keep = foreach(i = 1:length(unique(basename_n))) %do% {
    sub_mat = results[basename_n == i, basename_n == i]
    diag(sub_mat) = 0
    ! rowQuantiles(x = sub_mat, probs = 0.60) <= opt$min_correlation
}

to_keep = unlist(to_keep)
results = results[to_keep, to_keep]
basename_n = basename_n[to_keep]
Index = Index[to_keep]

write.matrix(
    x = results,
    file = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_per_cell_after_filtering.mx'
    ),
    sep = '\t'
)

color_basebanes = selcol(length(unique(basename_n)))

jpeg(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_plot_per_cell_after_filter.jpg'
    )
)

heatmap.2(
    results,
    trace = "none",
    dendrogram = 'none',
    Colv = F,
    Rowv = F,
    breaks = seq(0, 1, length.out = 101),
    col = color(100),
    density.info =  'density',
    key.title = 'Pearson',
    RowSideColors = color_basebanes[as.numeric(basename_n)],
    ColSideColors = color_basebanes[as.numeric(basename_n)],
    labRow = FALSE,
    labCol = FALSE
)

invisible(dev.off())

#filter out samples that don't correlate ans save
signal_smoothed = signal_smoothed %>%
    filter(index %in% Index) %>%
    separate(index, c('group', 'index'), sep = ' _ ') %>% 
    mutate(group = factor(group, level = unique(opt$groups)))

rep_percentage = signal_smoothed %>%
    group_by(Cell,basename,group, index) %>%
    summarise(Rep_percentage = mean(Rep))

plot = rep_percentage %>%
    ggplot(aes(Rep_percentage, color = group)) +
    geom_density(aes(y = ..scaled..)) +
    scale_x_continuous(labels = scales::percent) +
    xlab('Percentage of the genome that has been replicated') +
    ylab('density') + coord_cartesian(xlim = c(0, 1))

suppressMessages(ggsave(
    plot = plot,
    filename = paste0(
        opt$out,
        opt$output_file_base_name,
        '_percentage_of_replicating_cells_after_filtering.pdf'
    )
))

new_index_list = rep_percentage %>%
    ungroup() %>%
    arrange(Rep_percentage) %>%
    group_by(group) %>%
    mutate(newIndex = 1:n()) %>%
    arrange(group,newIndex) %>%
    dplyr::select(oldIndex=index, newIndex,Cell,basename,group)

write_tsv(new_index_list,paste0(
    opt$out,
    '/',
    opt$output_file_base_name,
    '_new_old_index_correspondance_after_filtering.txt'
))

signal_smoothed = signal_smoothed %>%
    ungroup() %>%
    inner_join(new_index_list, by = c('Cell','index'='oldIndex', 'basename','group')) %>% 
    dplyr::select(chr,
                  start,
                  end,
                  CN,
                  background,
                  CN_bg,
                  th,
                  Rep,
                  PercentageReplication,
                  Cell,
                  basename,
                  group,
                  newIndex)


write_delim(
    x = signal_smoothed,
    path = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_single_cells_CNV_',
        opt$binsSize,
        '.tsv'
    ),
    delim = '\t',
    col_names = T
)

#select used data and save the new per cell files
used_cells=  rbind( new_index_list%>%
                        dplyr::select(Cell,basename,group )%>%ungroup(),
                    G1_G2_cells%>%
                        dplyr::select(Cell,basename,group )%>%ungroup())


data=data%>%inner_join(used_cells,Joining, by = c("Cell", "basename", "group"))
system(paste0('mkdir -p ', opt$out, '/Cells_used_in_the_analysis_info'))

bs=foreach(i=unique(data$basename))%do%{
    data%>%
        filter(basename==i)%>%
        dplyr::select(Cell,normalized_dimapd,mean_ploidy,ploidy_confidence,is_high_dimapd,is_noisy,coverage_per_1Mbp)%>%
        write_csv(paste0(opt$out, '/Cells_used_in_the_analysis_info/',i,'_per_Cell_summary_metrics.csv'))
    i
    
}

rm('bs')
rm('G1_G2_cells')
rm('new_index_list')

#calculate replication timing normalizing each bin by the number of cells in each bin and then calculating the average of the average
# select simmetrically distributed cells.

rep_percentage = rep_percentage%>%
    group_by(group)%>%
    mutate(min_perc=1-max(Rep_percentage),
           max_perc=1-min(Rep_percentage))%>%
    filter(Rep_percentage >= round(min_perc,2),
           Rep_percentage <= round(max_perc,2))%>%
    mutate(min_perc=1-max(Rep_percentage),
           max_perc=1-min(Rep_percentage))%>%
    filter(Rep_percentage >= round(min_perc,2),
           Rep_percentage <= round(max_perc,2))

plot = rep_percentage %>%
    ggplot(aes(Rep_percentage, color = group)) +
    geom_density(aes(y = ..scaled..)) +
    scale_x_continuous(labels = scales::percent) +
    xlab('Percentage of the genome that has been replicated') +
    ylab('density') + coord_cartesian(xlim = c(0, 1))

suppressMessages(ggsave(
    plot = plot,
    filename = paste0(
        opt$out,
        opt$output_file_base_name,
        '_percentage_of_replicating_cells_used_for_RT_calculation.pdf'
    )
))

# bin the cells based on their percentage of replication in order have continuous bins with at least one cell.

RT_binning = foreach(Group = unique(rep_percentage$group), .combine = 'rbind') %:%
    foreach(bins = 1:10, .combine = 'rbind') %do% {
        rep_group = rep_percentage %>%
            ungroup() %>%
            filter(group == Group) %>%
            mutate(rep_group = ceiling(100 * Rep_percentage / bins)) %>%
            arrange(rep_group) %>%
            pull(rep_group) %>%
            unique()
        
        cont_rep_group = min(rep_group):max(rep_group)
        
        if (length(cont_rep_group) == length(rep_group)) {
            if (all(rep_group == cont_rep_group)) {
                tibble(group = Group,
                       Binning_step = bins)
            } else{
                tibble()
            }
        } else{
            tibble()
            
        }
    }

RT_binning=RT_binning%>%
    group_by(group)%>%
    summarise(Binning_step=min(Binning_step))


scRT =signal_smoothed%>%
    group_by(group)%>%
    mutate(min_perc=1-max(PercentageReplication),
           max_perc=1-min(PercentageReplication)) %>%
    filter(PercentageReplication >= min_perc,
           PercentageReplication <= max_perc)%>%
    mutate(min_perc=1-max(PercentageReplication),
           max_perc=1-min(PercentageReplication)) %>%
    filter(PercentageReplication >= min_perc,
           PercentageReplication <= max_perc)%>%
    inner_join(RT_binning, by = "group")%>%
    mutate(RepGroup=(ceiling(100*PercentageReplication/Binning_step)))%>%
    group_by(chr, start, end, RepGroup, group) %>%
    summarise(Rep = mean(Rep))%>%
    ungroup() %>%
    group_by(chr, start, end, group) %>%
    summarise(RT = mean(Rep)) %>%
    group_by(group) %>%
    mutate(RT = (RT - min(RT)) / (max(RT) - min(RT)))%>%
    dplyr::select(chr,start,end,RT,group)

write_delim(
    x = scRT,
    path = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_calculated_replication_timing_',
        opt$binsSize,
        '.tsv'
    ),
    delim = '\t',
    col_names = T
)

#plots
if (opt$plot) {
    system(paste0('mkdir -p ', opt$out, '/regions'))
    if (!'region' %in% names(opt)) {
        for (i in 1:length(Chr_Size$chr)) {
            region = round(runif(1, min = 1000000, max = 0.8 * Chr_Size$size[i]),
                           0)
            Chr = Chr_Size$chr[i]
            Start = region
            End = region + round(0.2 * Chr_Size$size[i])
            
            # prepare name file
            name_reg = min(str_length(str_extract(Start, '0{1,10}$')),
                           str_length(str_extract(End, '0{1,10}$')))
            name_reg = paste(
                Chr,
                case_when(
                    is.na(name_reg) ~ paste0(Start, 'bp_', End, 'bp'),
                    name_reg < 3 ~ paste0(Start, 'bp_', End, 'bp'),
                    name_reg < 6 ~ paste0(Start / 10 ^ 3, 'Kb_', End / 10 ^
                                              3, 'Kb'),
                    name_reg >= 6 ~ paste0(Start / 10 ^ 6, 'Mb_', End /
                                               10 ^ 6, 'Mb')
                )
            )
            
            
            track_toplot = signal_smoothed %>%
                filter(
                    chr %in% Chr,
                    (start >= Start & end <= End) |
                        (start <= Start & end >= Start) |
                        (start <= End & end >= End)
                ) %>%
                mutate(
                    start = ifelse(start < Start, Start, start),
                    end = ifelse(end > End , End, end)
                )%>%
                filter(start!=end)
            
            if (length(track_toplot$chr) != 0) {
                max_index = track_toplot %>% pull(newIndex) %>% max()
                
                scRT_toplot = scRT %>%
                    ungroup() %>%
                    filter(
                        chr %in% Chr,
                        (start >= Start & end <= End) |
                            (start <= Start & end >= Start) |
                            (start <= End & end >= End)
                    ) %>%
                    mutate(
                        RT = RT ,
                        start = ifelse(start < Start, Start, start),
                        end = ifelse(end > End , End, end)
                    )%>%
                    filter(start!=end)
                
                plot =  ggplot() +
                    geom_rect(
                        data = track_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = -newIndex,
                            ymax = -newIndex - 1,
                            fill = as.numeric(Rep)
                        )
                    ) + geom_rect(
                        data = scRT_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = 0,
                            ymax = max_index / 20,
                            fill = RT
                        ),
                        inherit.aes = F
                    ) +
                    facet_grid(chr ~ group, scale = 'free') +
                    scale_fill_gradient(
                        low = 'blue',
                        high = 'red',
                        limits = c(0, 1)
                    ) +
                    scale_x_continuous(
                        labels = function(x)
                            paste(x / 1000000, 'Mb', sep = ' ')
                    ) +
                    labs(y = 'S phase progression', fill = "Replication Timing\nBinary Replication Profile\n") +
                    theme(
                        legend.position = 'top',
                        axis.text.x = element_text(angle = 45, hjust = 1)
                    )
                
                if ('referenceRT' %in% names(opt)) {
                    RT_toplot = Reference_RT %>%
                        filter(
                            chr %in% Chr,
                            (start >= Start & end <= End) |
                                (start <= Start & end >= Start) |
                                (start <= End & end >= End)
                        ) %>%
                        mutate(
                            RT = RT ,
                            start = ifelse(start < Start, Start, start),
                            end = ifelse(end > End , End, end)
                        )
                    if (length(RT_toplot$chr) != 0) {
                        plot = plot +
                            geom_rect(
                                data = RT_toplot,
                                aes(
                                    xmin = start,
                                    xmax = end,
                                    ymin = max_index / 20,
                                    ymax = max_index / 10,
                                    fill = RT
                                ),
                                inherit.aes = F
                            )  +
                            scale_y_discrete(
                                limits = c(
                                    0.075 * max_index,
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c(
                                    opt$ref_name,
                                    'RT',
                                    seq(1,  max_index, round(max_index / 20))
                                )
                            )
                    } else{
                        plot = plot +
                            scale_y_discrete(
                                limits = c(
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c('RT',  seq(
                                    1,  max_index, round(max_index / 20)
                                ))
                            )
                    }
                } else{
                    plot = plot +
                        scale_y_discrete(
                            limits = c(max_index / 40, -seq(
                                1, max_index, round(max_index / 20)
                            )),
                            labels = c('RT',  seq(
                                1,  max_index, round(max_index / 20)
                            ))
                        )
                }
                
                suppressMessages(ggsave(
                    plot,
                    filename = paste0(
                        opt$out,
                        '/regions/',
                        opt$output_file_base_name,
                        '_plot_RT_',
                        name_reg,
                        '.pdf'
                    )
                ))
            }
        }
    } else{
        if (file.exists(opt$region)) {
            #load bed file if exist
            opt$region = read_tsv(opt$region, col_names = c('chr', 'start', 'end')) %>%
                mutate(
                    n_0_start = str_length(str_extract(start, '0{1,10}$')),
                    n_0_end = str_length(str_extract(end, '0{1,10}$')),
                    unit = min(
                        factor(
                            case_when(
                                is.na(n_0_start) ~ 'bp',
                                n_0_start < 3 ~ 'bp',
                                n_0_start < 6 ~ 'Kb',
                                n_0_start >= 6 ~ 'Mp'
                            ),
                            levels = c('bp', 'Kb', 'Mp'),
                            ordered = TRUE
                        ),
                        factor(
                            case_when(
                                is.na(n_0_end) ~ 'bp',
                                n_0_end < 3 ~ 'bp',
                                n_0_end < 6 ~ 'Kb',
                                n_0_end >= 6 ~ 'Mp'
                            ),
                            levels = c('bp', 'Kb', 'Mp'),
                            ordered = TRUE
                        )
                    ),
                    name_reg = paste(
                        chr,
                        case_when(
                            unit == 'bp' ~ paste0(start, unit, '_', end, unit),
                            unit == 'Kb' ~ paste0(start / 10 ^ 3, unit, '_', end /
                                                      10 ^ 3, unit),
                            unit == 'Mb' ~ paste0(start / 10 ^ 6, unit, '_', end /
                                                      10 ^ 6, unit)
                        ),
                        sep = '_'
                    )
                ) %>%
                dplyr::select(-unit, -n_0_start, -n_0_end)
        } else{
            #reshape regions
            opt$region = tibble(coord = str_split(opt$region, pattern = ',')[[1]]) %>%
                mutate(name_reg = str_replace_all(
                    coord,
                    pattern = '[-:]',
                    replacement = '_'
                )) %>%
                separate(coord, c('chr', 'pos'), ':') %>%
                separate(pos, c('start', 'end'), '-') %>%
                mutate(
                    start_unit = str_extract(start, pattern = '.{2}$'),
                    start = as.numeric(str_remove(
                        start, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]"
                    )) * case_when(
                        grepl(x = start_unit, pattern =  '[Kk][Bb]') ~ 1000,
                        grepl(x = start_unit, pattern = '[Mm][Bb]') ~ 1000000,
                        grepl(x = start_unit, pattern = '[Bp][Pp]') ~ 1,
                        grepl(x = start_unit, pattern =  '[0-9][0-9]') ~ 1
                    ),
                    end_unit = str_extract(end, pattern = '.{2}$'),
                    
                    end = as.numeric(str_remove(
                        end, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]"
                    )) * case_when(
                        grepl(x = end_unit, pattern =  '[Kk][Bb]') ~ 1000,
                        grepl(x = end_unit, pattern = '[Mm][Bb]') ~ 1000000,
                        grepl(x = end_unit, pattern = '[Bp][Pp]') ~ 1,
                        grepl(x = end_unit, pattern =  '[0-9][0-9]') ~ 1
                    )
                ) %>%
                dplyr::select(-start_unit, -end_unit)
        }
        
        
        for (i in 1:length(opt$region$chr)) {
            Chr = opt$region$chr[i]
            Start = opt$region$start[i]
            End = opt$region$end[i]
            
            track_toplot = signal_smoothed %>%
                filter(
                    chr %in% Chr,
                    (start >= Start & end <= End) |
                        (start <= Start & end >= Start) |
                        (start <= End & end >= End)
                ) %>%
                mutate(
                    start = ifelse(start < Start, Start, start),
                    end = ifelse(end > End , End, end)
                )
            
            if (length(track_toplot$chr) != 0) {
                max_index = track_toplot %>% pull(newIndex) %>% max()
                
                scRT_toplot = scRT %>%
                    ungroup() %>%
                    filter(
                        chr %in% Chr,
                        (start >= Start & end <= End) |
                            (start <= Start & end >= Start) |
                            (start <= End & end >= End)
                    ) %>%
                    mutate(
                        RT = RT,
                        start = ifelse(start < Start, Start, start),
                        end = ifelse(end > End , End, end)
                    )
                
                plot =  ggplot() +
                    geom_rect(
                        data = track_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = -newIndex,
                            ymax = -newIndex - 1,
                            fill = as.numeric(Rep)
                        )
                    ) + geom_rect(
                        data = scRT_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = 0,
                            ymax = max_index / 20,
                            fill = RT
                        ),
                        inherit.aes = F
                    ) +
                    facet_grid(chr ~ group, scale = 'free') +
                    scale_fill_gradient(
                        low = 'blue',
                        high = 'red',
                        limits = c(0, 1)
                    ) +
                    scale_x_continuous(
                        labels = function(x)
                            paste(x / 1000000, 'Mb', sep = ' ')
                    ) +
                    labs(y = 'S phase progression', fill = "RT") +
                    theme(
                        legend.position = 'top',
                        axis.text.x = element_text(angle = 45, hjust = 1)
                    )
                
                
                if ('referenceRT' %in% names(opt)) {
                    RT_toplot = Reference_RT %>%
                        filter(
                            chr %in% Chr,
                            (start >= Start & end <= End) |
                                (start <= Start & end >= Start) |
                                (start <= End & end >= End)
                        ) %>%
                        mutate(
                            RT = RT ,
                            start = ifelse(start < Start, Start, start),
                            end = ifelse(end > End , End, end)
                        )%>%
                        filter(start!=end)
                    
                    if (length(RT_toplot$chr) != 0) {
                        plot = plot +
                            geom_rect(
                                data = RT_toplot,
                                aes(
                                    xmin = start,
                                    xmax = end,
                                    ymin = max_index / 20,
                                    ymax = max_index / 10,
                                    fill = RT
                                ),
                                inherit.aes = F
                            ) +
                            scale_y_discrete(
                                limits = c(
                                    0.075 * max_index,
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c(
                                    opt$ref_name,
                                    'RT',
                                    seq(1,  max_index, round(max_index / 20))
                                )
                            )
                    } else{
                        plot = plot +
                            scale_y_discrete(
                                limits = c(
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c('RT',  seq(
                                    1,  max_index, round(max_index / 20)
                                ))
                            )
                    }
                } else{
                    plot = plot +
                        scale_y_discrete(
                            limits = c(max_index / 40, -seq(
                                1, max_index, round(max_index / 20)
                            )),
                            labels = c('RT',  seq(
                                1,  max_index, round(max_index / 20)
                            ))
                        )
                }
                plot = plot + facet_wrap(~ group)
                suppressMessages(ggsave(
                    plot,
                    filename = paste0(
                        opt$out,
                        '/regions/',
                        opt$output_file_base_name,
                        '_plot_RT_',
                        opt$region$name_reg,
                        '.pdf'
                    )
                ))
            }
        }
    }
}

##### RT distributions
if ('referenceRT' %in% names(opt)) {
    RTs = rbind(
        scRT %>%
            ungroup() ,
        
        Reference_RT %>%
            mutate(
                RT = RT / max(RT, na.rm = T),
                group = opt$ref_name
            )
    )
    
    
} else{
    RTs =  scRT 
    
}

pdf(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name
        ,
        '_RT_distribution_plot.pdf'
    )
)

RTs %>%
    ggplot(aes(RT, fill = group)) + geom_density(alpha = 0.2, aes(y = ..count.. /
                                                                         sum(..count..))) +
    xlab('RT') + ylab('density')

invisible(dev.off())


##### Correlation Calculated RT and reference

if (length(unique(RTs$group)) != 1) {
    
    RTs = RTs%>%
        spread(key = group, value = RT) %>%
        filter(complete.cases(.))%>%
        dplyr::select(-chr,-start,-end)
    
    plot = ggcorrplot(
            RTs %>% 
            cor(),
        lab = T,
        lab_col = 'white',legend.title = 'Pearson\ncorrelation',
        colors = c('#21908CFF', '#F0F921FF', '#BB3754FF')
    )
    
    suppressMessages( ggsave(
        plot = plot,
        filename =paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_correlation_plot_RTs.pdf'
        )
    ))
    
    suppressMessages( ggsave(
        plot = ggpairs(RTs,
                       diag = list(continuous =function(data, mapping, ...){
                           names=colnames(data)
                           color=rainbow(length(names))
                           p <- ggplot(data,mapping)+
                               geom_density(aes(y=..density../max(..density..)),
                                            fill=color[which(names==as_label(mapping$x))])+
                               scale_x_continuous(breaks = c(0,0.5,1))+
                               scale_y_continuous(breaks = c(0,0.5,1))
                           return(p)
                       }),
                       upper = list(continuous =function(data, mapping, ...){
                           
                           data=tibble(
                               xmin=-Inf,
                               xmax=Inf,
                               ymin=-Inf,
                               ymax=Inf,
                               Corr=cor(data[as_label(mapping$x)],data[as_label(mapping$y)])
                           )
                           
                           p <- ggplot(data,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax,fill=Corr)) + 
                               geom_rect()+
                               annotate('text',0.5,0.5,label=paste("Corr:",round(data$Corr,3),sep = '\n'))+
                                scale_fill_gradient2(low = 'blue',high = 'red',mid = 'yellow',midpoint = 0,limits=c(-1,1))+
                               coord_cartesian(xlim = c(0,1),ylim = c(0,1))+
                                scale_x_continuous(breaks = c(0,0.5,1))+
                                scale_y_continuous(breaks = c(0,0.5,1))
                           
                           return(p)
                       }),
                       lower = list(continuous =function(data, mapping, ...){
                           p <- ggplot(data = data, mapping = mapping) + 
                               geom_hex(bins=50,aes(fill=..ndensity..))+
                               scale_fill_gradientn('Density',colours =rainbow(7))+
                               coord_cartesian(xlim = c(0,1),ylim = c(0,1))+
                                scale_x_continuous(breaks = c(0,0.5,1))+
                                scale_y_continuous(breaks = c(0,0.5,1))+
                               geom_abline(slope = 1,color='black',alpha=0.5)
                           
                           return(p)
                       }),legend = c(2,1))+ theme(legend.position = "right",
                                                  axis.text.x = element_text(angle = 45,hjust = 1)),
        filename =paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_paired_density_plot_RTs.pdf'
        )
    ))
 
 }

#joing RTs with relative signals
signal_smoothed = signal_smoothed %>%
    dplyr::select(group, chr, start, end, Rep,PercentageReplication) %>%
    inner_join(scRT, by = c("group", "chr", "start", "end"))  %>%
    mutate(
        RT = 10 * (1-RT) ,
        time = round( RT - 10*PercentageReplication,1)
    )


#test multiple time windows
cl <- makeCluster(opt$cores)
registerDoSNOW(cl)

x = signal_smoothed%>%
    group_by(group,time,RT,chr,start,end)%>%
    summarise(percentage=mean(Rep))


x %>%
    ungroup()%>%
    dplyr::select(-RT)%>%
    write_tsv(
        paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_scRT_variability.tsv'
        )
    )

# fucntion to assigne categories
    split_into_categoreis=Vectorize(function(RT,number){
            if(number==3){
                return( case_when(
                    RT < 3 ~ '1 - Early',
                    RT >= 3 & RT < 6 ~ '2 - Mid',
                    RT >= 6  ~ '3 - Late'
                ))
            }else if (number==5){
                return( case_when(
                    RT < 2 ~ '1 - Very Early',
                    RT >= 2 & RT < 4  ~ '2 - Early',
                    RT >= 4 & RT < 6 ~ '3 - Mid',
                    RT >= 6 & RT < 8 ~ '4 - Late',
                    RT >= 8  ~ '5 - Very Late'))
            }else {
                return( case_when(
                    RT < 5 ~ '1 - Early',
                    RT >= 5  ~ '2 - Late'
                ))
    }
        },vectorize.args = 'RT' )
    cat_levels=function(number){
            if(number==3){
                return( c(
                    '0 - All',
                    '1 - Early',
                    '2 - Mid ',
                    '3 - Late'
                ))
            }else if (number==5){
                return( c(
                    '0 - All',
                    '1 - Very Early',
                    '2 - Early',
                    '3 - Mid',
                    '4 - Late',
                    '5 - Very Late'
                ))
            }else {
                return( c(
                    '0 - All',
                    '1 - Early',
                    '2 - Late'
                )
                )
            }
        }

x = rbind(x  %>%
    mutate(
        Cat_RT = split_into_categoreis(RT,number = opt$N_of_RT_groups),
        Cat_RT = factor(
            Cat_RT,
            levels = cat_levels( opt$N_of_RT_groups)
        )
    ),
    x%>%
    mutate(
        Cat_RT = '0 - All',
        Cat_RT = factor(
            Cat_RT,
            levels = cat_levels( opt$N_of_RT_groups)
        )
    ))


x=x%>%
    group_by(group,time,Cat_RT)%>%
    summarise(percentage=mean(percentage))

#T25_75 function
T25_75 = function(df, name, EL) {
    model = tryCatch(
        nls(percentage ~ SSlogis(time, Asym, xmid, scal),
            data = df[, c('percentage', 'time')]%>%
                add_row(percentage=1,time=-10)%>%
                add_row(percentage=0,time=10),
            control = nls.control(maxiter = 100),
            algorithm = 'port',
            start = c(Asym=1,xmid=0,scal=-0.5)
            ),
        #If the data cannot be fitted with a Gauss-Newton algorithm, try the
        #Golub and Pereyra algorithm for the solution of a nonlinear least squares
        #problem which assumes a number of the parameters are linear.
        #Also, add a higher tolerance (1e-04 Vs 1e-05).
        error = tryCatch(function(e)
            nls(
                percentage ~ SSlogis(time, Asym, xmid, scal),
                data = df[, c('percentage', 'time')]%>%
                    add_row(percentage=1,time=-10)%>%
                    add_row(percentage=0,time=10),
                algorithm = 'plinear',
                control = nls.control(maxiter = 100,tol = 1e-04, warnOnly = T)
            ),
            error = function(e) print('Try to reduce the number of RT groups') 
            )
    )
    min = min(df$time)
    max = max(df$time)
    data = predict(model,
                   newdata = data.frame(time = seq(min, max, 0.01)),
                   type = "l")
    result = data.frame(
        time = seq(min, max, 0.01),
        percentage = data,
        group = name
    )
    t = result %>%
        mutate(
            distance75 = abs(percentage - 0.75),
            distance25 = abs(percentage - 0.25)
        ) %>%
        mutate(
            min75 = min(distance75),
            min25 = min(distance25),
            t75 = distance75 == min75,
            t25 = distance25 == min25
        ) %>%
        dplyr::select(group, time, percentage, t75, t25)  %>%
        mutate(Cat_RT = EL)
    
    return(t)
}

#calculate tresholds 25% 75% replication keeping in account early and late domains
fitted_data = foreach(
    group = unique(x$group),
    .combine = 'rbind',
    .packages = c('tidyverse', 'foreach'),
    .errorhandling = 'remove'
) %do% {
    temp = foreach(
            EL = unique(x$Cat_RT),
        .combine = 'rbind',
        .packages = c('tidyverse', 'foreach'),
        .errorhandling = 'remove'
    ) %dopar% {
        t = T25_75(df = x[x$group == group &
                              x$Cat_RT == EL, ], group, EL)
    }
    temp
}

t = fitted_data %>% filter(t75 | t25) %>%
    gather('t', 'value', t25, t75) %>%
    filter(value) %>%
    dplyr::select(-percentage, -value) %>%
    spread(t, time) %>%
    mutate(Twidth = abs(t75 - t25))

t %>% write_tsv(paste0(opt$out,
                       '/',
                       opt$output_file_base_name,
                       '_Twidth.tsv'))


plot=ggplot(x) +
    geom_point(aes(time,percentage,color=group))+
    geom_line(data=fitted_data,aes(time,percentage),color='blue')+
    scale_x_reverse()+scale_y_continuous(labels = scales::percent)+
    geom_vline(data=t,aes(xintercept=t25),color='red')+
    geom_vline(data=t,aes(xintercept=t75),color='red')+
    geom_text(data=t,aes(label=paste('TW\n',Twidth)),x=Inf,y=0.5, hjust=1.25)+
    facet_grid(group~Cat_RT)

ncat=length(unique(x$Cat_RT))
nbasen=length(unique(x$group))
suppressMessages(ggsave(
    plot,
    filename = paste0(opt$out,
                      '/',
                      opt$output_file_base_name,
                      '_Twidths_extended.pdf'),width = 2.2*ncat,height = 4*nbasen
))


p = ggplot(t) +
    geom_col(aes(Cat_RT, Twidth, fill = group), position = 'dodge') +
    ylab('Twidth') + xlab('')

suppressMessages(ggsave(
    p,
    filename = paste0(opt$out,
                      '/',
                      opt$output_file_base_name,
                      '_Twidths.pdf')
))

if (opt$Var_against_reference) {
    #joing reference with relative signals
    signal_smoothed = signal_smoothed %>%
        dplyr::select(group, chr, start, end, Rep,PercentageReplication) %>%
        inner_join(Reference_RT, by = c("chr", "start", "end"))  %>%
        mutate(
            RT = 10 * (1-RT) ,
            time = round(RT - 10*PercentageReplication,1)
        )
    
    
    x = signal_smoothed%>%
        group_by(group,time,RT,chr,start,end)%>%
        summarise(percentage=mean(Rep))
        
        
    x %>%
        ungroup()%>%
        dplyr::select(-RT)%>%
        write_tsv(
            paste0(
                opt$out,
                '/',
                opt$output_file_base_name,
                '_scRT_variability_on_reference.tsv'
            )
        )
    
    x=x%>%
        group_by(group,time,Cat_RT)%>%
        summarise(percentage=mean(percentage)) 
    
    #calculate tresholds 25% 75% replication keeping in account early and late domains  ##WHY IS THIS REPEATED ??
    fitted_data = foreach(
        group = unique(x$group),
        .combine = 'rbind',
        .packages = c('tidyverse', 'foreach'),
        .errorhandling = 'remove'
    ) %do% {
        temp = foreach(
            EL = unique(x$Cat_RT),
            .combine = 'rbind',
            .packages = c('tidyverse', 'foreach'),
            .errorhandling = 'remove'
        ) %dopar% {
            t = T25_75(df = x[x$group == group &
                                  x$Cat_RT == EL, ], group, EL)
        }
        temp
    }
    
    t = fitted_data %>% filter(t75 | t25) %>%
        gather('t', 'value', t25, t75) %>%
        filter(value) %>%
        dplyr::select(-percentage, -value) %>%
        spread(t, time) %>%
        mutate(Twidth = abs(t75 - t25))
    
    t %>% write_tsv(paste0(opt$out,
                           '/',
                           opt$output_file_base_name,
                           '_Twidth_ref_RT.tsv'))
    
    
    plot=ggplot(x) +
        geom_point(aes(time,percentage,color=group))+
        geom_line(data=fitted_data,aes(time,percentage),color='blue')+
        scale_x_reverse()+scale_y_continuous(labels = scales::percent)+
        geom_vline(data=t,aes(xintercept=t25),color='red')+
        geom_vline(data=t,aes(xintercept=t75),color='red')+
        geom_text(data=t,aes(label=paste('TW\n',Twidth)),x=Inf,y=0.5, hjust=1.25)+
        facet_grid(group~Cat_RT)
    
    ncat=length(unique(x$Cat_RT))
    nbasen=length(unique(x$group))
    suppressMessages(ggsave(
        plot,
        filename = paste0(opt$out,
                          '/',
                          opt$output_file_base_name,
                          '_Twidths_extended_ref_RT.pdf'),width = 2.2*ncat,height = 4*nbasen
    ))
    
    p = ggplot(t) +
        geom_col(aes(Cat_RT, Twidth, fill = group), position = 'dodge') +
        ylab('Twidth') + xlab('')
    
    suppressMessages(ggsave(
        p,
        filename = paste0(opt$out,
                          '/',
                          opt$output_file_base_name,
                          '_Twidths_ref_RT.pdf')
    ))
    
}

stopCluster(cl)


print('done')

