#!/usr/local/bin/Rscript --slave
#parse input
suppressPackageStartupMessages(library(optparse, quietly = TRUE))

options(stringsAsFactors = FALSE)
options(warn = 1, scipen = 999)

option_list = list(
    make_option(
        c("-K", "--Kronos_conf_file"),
        type = "character",
        default = NULL,
        help = "Kronos setting file. If provided -F,-T,-S,-b and -g are ignored. Tab file containing: Per cell stat file /t tracks file /t settings file /t basename (optional) /t group (optional) ",
        metavar = "character"
    ),make_option(
        c("-F", "--file"),
        type = "character",
        default = NULL,
        help = "Per cell stat file , if multiple files are provided they have to be separated by a comma",
        metavar = "character"
    ),
    make_option(
        c("-T", "--tracks"),
        type = "character",
        default = NULL,
        help = "Tracks file,  if multiple files are provided they have to be separated by a comma",
        metavar = "character"
    ),
    make_option(
        c("-R", "--referenceRT"),
        type = "character",
        default = NULL,
        help = "Reference RT min=Late, max=Early, only one reference is allowed",
        metavar = "character"
    ),
    make_option(
        c("--ref_name"),
        type = "character",
        default = "Reference",
        help = "Name for the reference track [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-C", "--chrSizes"),
        type = "character",
        default = NULL,
        help = "Chromosome size file",
        metavar = "character"
    ),
    make_option(
        c("-r", "--region"),
        type = "character",
        default = NULL,
        help = "Region to plot  chr:start-end (multiple regins can be separated by a comma)",
        metavar = "character"
    ),
    make_option(
        c("-o", "--out"),
        type = "character",
        default = "output",
        help = "Output directory [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-b", "--base_name"),
        type = "character",
        default = "exp",
        help = "Base name for files names [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-f", "--output_file_base_name"),
        type = "character",
        default = "out",
        help = "Base name for the output file [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-g", "--groups"),
        type = "character",
        help = "Grouping names of multiple basenames [default= base_name]",
        metavar = "character"
    ),
    make_option(
        c("-S", "--settings_file"),
        type = "character",
        help = "File generated by Kronos diagnostic",
        metavar = "character"
    ),
    make_option(
        c("-B", "--binsSize"),
        type = "character",
        default = '500Kb',
        help = "RT resolution (supports units) [default= %default] ",
        metavar = "character"
    ),
    make_option(
        c("-k", "--keepXY"),
        type = "logical",
        default = FALSE,
        action = "store_true",
        help = "keep XY chromosomes in the analysis",
        metavar = "logical"
    ),
    make_option(
        c("-c", "--cores"),
        type = "integer",
        default = 3,
        help = "Numbers of parallel jobs to run [default= %default] ",
        metavar = "integer"
    ),
    make_option(
        c("-p", "--plot"),
        type = "logical",
        default = F,
        action = "store_true",
        help = "If selected prints some randome regins, if -r is selected those regins are use to print RT [default= %default] ",
        metavar = "logical"
    ),
    make_option(
        c("--Var_against_reference"),
        type = "logical",
        default = F,
        action = "store_true",
        help = "Variability metrics are calculated usign reference RT in addiction to the calculated one [default= %default] ",
        metavar = "logical"
    ),
    make_option(
        c("--min_correlation"),
        type = "double",
        default = 0.25,
        help = "Minimum correlation value between one cell and its best correlating cell for this cell to not be discarded [default= %default] ",
        metavar = "double"
    )
)

#recover inputs
opt = parse_args(object = OptionParser(option_list = option_list))

#load libraries
suppressPackageStartupMessages(library(tidyverse, quietly = TRUE))
suppressPackageStartupMessages(library(foreach, quietly = TRUE))
suppressPackageStartupMessages(library(doSNOW, quietly = TRUE))
suppressPackageStartupMessages(library(gplots, quietly = TRUE))
suppressPackageStartupMessages(library(matrixStats, quietly = TRUE))
suppressPackageStartupMessages(library(RColorBrewer, quietly = TRUE))
suppressPackageStartupMessages(library(GenomicRanges, quietly = TRUE))
suppressPackageStartupMessages(library(MASS, quietly = TRUE))
#check inputs
if('Kronos_conf_file' %in% names(opt)) {
    
    settings=tryCatch(expr = read_tsv(opt$Kronos_conf_file,col_names = c('file','traks','settings','basename','groups'),col_types = cols())%>%
        mutate(
            basename=ifelse(is.na(basename),paste0('exp',row_number()),basename),
            groups=ifelse(is.na(groups),basename,groups)
        ),
        error=function(e){stop('Settings file does not exitst')},
        warning=function(w){
            tmp=suppressWarnings(
            read_tsv(opt$Kronos_conf_file,col_names = c('file','traks','settings','basename','groups'),col_types = cols())%>%
                mutate(
                    basename=ifelse(is.na(basename),paste0('exp',row_number()),basename),
                    groups=ifelse(is.na(groups),basename,groups)
                ))
            warning('missing basenames and groups were replaced with default parameters')
            return(tmp)})
    
    #reformat files
    opt$file = settings$file
    
    opt$settings_file = settings$settings
    
    opt$tracks = settings$traks
    
    opt$base_name = settings$basename
    
    opt$groups = settings$groups
    
} else{
    
    if (!'file' %in% names(opt)) {
        stop("Per cell stat file or Kronos setting file must be provided. See script usage (--help)")
    }
    
    if (!'tracks' %in% names(opt)) {
        stop("File containing cells CNV or Kronos setting file must be provided. See script usage (--help)")
    }
    
    if (!'settings_file' %in% names(opt)) {
        stop("File containing settings sizes must be provided. See script usage (--help)")
    }
    
    if (!'groups' %in% names(opt)) {
        opt$groups = opt$base_name
    }
    
    #reformat files
    opt$file = str_split(opt$file, ',')[[1]]
    
    opt$settings_file = str_split(opt$settings_file, ',')[[1]]
    
    opt$tracks = str_split(opt$tracks, ',')[[1]]
    
    opt$base_name = str_split(opt$base_name, ',')[[1]]
    
    opt$groups = str_split(opt$groups, ',')[[1]]
    
    
}    
if (!'chrSizes' %in% names(opt)) {
    stop("File containing Chromosomes sizes must be provided. See script usage (--help)")
}



if (opt$Var_against_reference) {
    if (!'referenceRT' %in% names(opt)) {
        warning("Reference genome not provided")
        opt$Var_against_reference = F
    }
}
# convert binsize to numeric

extract_unit = str_extract(opt$binsSize, pattern = '.{2}$')
resolution = as.numeric(str_remove(opt$binsSize, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]")) * case_when(
    grepl(x = extract_unit, pattern =  '[Kk][Bb]') ~ 1000,
    grepl(x = extract_unit, pattern = '[Mm][Bb]') ~ 1000000,
    grepl(x = extract_unit, pattern = '[Bp][Pp]') ~ 1,
    grepl(x = extract_unit, pattern =  '[0-9][0-9]') ~ 1
)

if (any(is.na(resolution))) {
    stop('binsize have an incorrect format')
}

# prepare name file
if (grepl(x = extract_unit, pattern =  '[0-9][0-9]')) {
    n_of_zeros = str_length(str_extract(opt$binsSize, '0{1,10}$'))
    opt$binsSize = case_when(
        is.na(n_of_zeros) ~ paste0(opt$binsSize, 'bp'),
        n_of_zeros < 3 ~ paste0(opt$binsSize, 'bp'),
        n_of_zeros < 6 ~ paste0(str_remove(opt$binsSize, '0{3}$'), 'Kb'),
        n_of_zeros >= 6 ~ paste0(str_remove(opt$binsSize, '0{6}$'), 'Mp')
    )
} else{
    opt$binsSize = opt$binsSize
}

#create directory
if (str_extract(opt$out, '.$') != '/') {
    opt$out = paste0(opt$out, '/')
}

system(paste0('mkdir -p ./', opt$out))


# check inputs
if (length(opt$tracks) != length(opt$file)) {
    stop("The number stat files does not match provided trakcs. See script usage (--help)")
}

if (length(opt$base_name) != length(opt$file)) {
    index = rep(
        1:length(opt$file),
        length(opt$file),
        each = length(opt$base_name),
        length.out = length(opt$file)
    )
    opt$base_name = paste(rep_len(opt$base_name, length(opt$file)), index, sep = '-')
    warning('basenames will be cyclicly recicled')
}

if (length(opt$groups) != length(opt$file)) {
    index = rep(
        1:length(opt$file),
        length(opt$file),
        each = length(opt$groups),
        length.out = length(opt$file)
    )
    opt$groups = paste(rep_len(opt$groups, length(opt$groups)), index, sep = '-')
    warning('groups variable will be cyclicly recicled')
}

#load genome sizes
if (!opt$keepXY) {
    Chr_Size <-
        read_delim(
            opt$chrSizes,
            delim = '\t',
            col_names = c('chr', 'size'),
            col_types = cols()
        ) %>%
        filter(!chr %in% c('chrX', 'chrY'))
} else{
    Chr_Size <-
        read_delim(
            opt$chrSizes,
            delim = '\t',
            col_names = c('chr', 'size'),
            col_types = cols()
        )
}

#chr order
chr_list = paste0('chr', c(1:56, 'X', 'Y'))

chr_list = chr_list[chr_list %in% unique(Chr_Size$chr)]

Chr_Size = Chr_Size %>%
    mutate(chr = factor(x =  chr, levels = chr_list)) %>%
    drop_na()

#load single cells infor
data <-
    foreach(
        i = 1:length(opt$file),
        .combine = 'rbind',
        .packages = 'tidyverse'
    ) %do% {
        inner_join(
            read_csv(opt$file[i], col_types = cols()) %>%
                mutate(
                    basename = factor(opt$base_name[i], levels = opt$base_name),
                    group = factor(opt$groups[i], levels = unique(opt$groups))
                ),
            read_tsv(opt$settings_file[i], col_types = cols()) %>%
                mutate(
                    basename = factor(opt$base_name[i], levels = opt$base_name),
                    group = factor(opt$groups[i], levels = unique(opt$groups))
                ),
            by = c('basename', 'group')
        )
    }

#filter data with too little reads per megabase (0.75milion reads for a diploid human genome)
data = data %>% filter(coverage_per_1Mbp >= RPM_TH)

#load tracks
all_tracks <-
    foreach(
        i = 1:length(opt$tracks),
        .combine = 'rbind',
        .packages = 'tidyverse'
    ) %do% {
        read_delim(opt$tracks[i], delim = '\t', col_types = cols()) %>%
            mutate(
                basename = factor(opt$base_name[i], levels = opt$base_name),
                group = factor(opt$groups[i], levels = unique(opt$groups)),
                chr = factor(x =  chr, levels = chr_list)
            ) %>%
            drop_na()
    }

# remove tracks not in use
CB = data %>%
    dplyr::select(Cell, basename)

all_tracks = all_tracks %>%
    inner_join(CB, by = c("Cell", "basename"))

rm('CB')

if ('referenceRT' %in% names(opt)) {
    Reference_RT <-
        read_delim(
            opt$referenceRT,
            delim = '\t',
            col_names = c('chr', 'start', 'end', 'RT'),
            col_types = cols()
        ) %>%
        mutate(chr = factor(x =  chr, levels = chr_list))
}

# calculate the new is_high_dimapd
data = data %>%
    mutate(
        is_noisy = as.logical(is_noisy),
        is_high_dimapd = ifelse(
            is.na(threshold_Sphase),
            is_high_dimapd,
            ifelse(normalized_dimapd > threshold_Sphase, T, F)
        ),
        is_noisy = ifelse(is_high_dimapd, T, is_noisy)
    )

median_ploidy_G1_G2_cells = data %>%
    filter(ifelse(
        is.na(threshold_G1G2phase),
        is_noisy == F,
        is_noisy == F &
            normalized_dimapd < threshold_G1G2phase
    )) %>%
    group_by(basename) %>%
    summarise(median_ploidy_G1_G2_cells = median(mean_ploidy))

data = data %>%
    inner_join(median_ploidy_G1_G2_cells, by = 'basename') %>%
    filter(
        mean_ploidy > median_ploidy_G1_G2_cells / 1.50 ,
        mean_ploidy < median_ploidy_G1_G2_cells * 2,
        !ploidy_confidence <= 2 | ploidy_confidence == -100
    ) %>%
    mutate(Type = ifelse(
        as.logical(is_high_dimapd) == T &
            as.logical(is_noisy) == T,
        'S-phase',
        ifelse(
            ifelse(
                is.na(threshold_G1G2phase),
                as.logical(is_high_dimapd) == F &
                    as.logical(is_noisy) == F,
                as.logical(is_high_dimapd) == F &
                    as.logical(is_noisy) == F &
                    normalized_dimapd < threshold_G1G2phase
            ),
            'G1/G2 cells',
            'unknown cells'
        )
    ))

#plot Variability vs ploidy
p = data %>%
    ggplot(aes(mean_ploidy,
               normalized_dimapd,
               color = Type)) +
    geom_point(alpha = 0.3) +
    scale_color_manual(
        values = c(
            'G1/G2 cells' = 'darkred',
            'S-phase' = 'darkgreen',
            'unknown cells' = 'darkorange'
        )
    ) +
    theme(legend.position = 'top', legend.title = element_blank()) +
    geom_vline(aes(xintercept = median_ploidy_G1_G2_cells)) + facet_wrap(group ~
                                                                             basename, scales = 'free') +
    xlab('Ploidy') + ylab('Variability')

suppressMessages(ggsave(
    p,
    filename = paste0(opt$out, '/', opt$output_file_base_name, '_plot.pdf')
))

# correct mean ploidy late S phase
data = data %>%
    mutate(
        mean_ploidy_corrected = ifelse(
            as.logical(is_noisy) == T &
                mean_ploidy < median_ploidy_G1_G2_cells,
            mean_ploidy / Sphase_second_part,
            ifelse(
                as.logical(is_noisy) == T &
                    mean_ploidy > median_ploidy_G1_G2_cells,
                mean_ploidy / Sphase_first_part,
                mean_ploidy
            )
        )
    )

#plot Variability vs ploidy (after correction)
p = data %>%
    ggplot(aes(mean_ploidy_corrected, normalized_dimapd, color = Type)) +
    geom_point(alpha = 0.3) +
    scale_color_manual(
        values = c(
            'G1/G2 cells' = 'darkred',
            'S-phase' = 'darkgreen',
            'unknown cells' = 'darkorange'
        )
    ) +
    theme(legend.position = 'top', legend.title = element_blank()) +
    geom_vline(aes(xintercept = median_ploidy_G1_G2_cells)) + facet_wrap(group ~
                                                                             basename, scales = 'free') +
    xlab('Ploidy') + ylab('Variability')

suppressMessages(ggsave(
    p,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_plot_sphase_corrected.pdf'
    )
))

#resolution
cl <- makeCluster(opt$cores)
registerDoSNOW(cl)

bins = foreach(chr = 1:length(Chr_Size$chr),
               .combine = 'rbind') %dopar% {
                   bins = seq(from = resolution,
                              to = Chr_Size$size[chr] ,
                              by =  resolution)
                   bins = data.frame(
                       chr =  factor(x =  Chr_Size$chr[chr], levels = chr_list),
                       start = bins - resolution,
                       end = bins
                   )
                   bins
               }

bins = bins %>%
    makeGRangesFromDataFrame(
        seqnames.field  = 'chr',
        start.field = 'start' ,
        end.field = 'end'
    )


#select Sphase cells
selected_data = data %>%
    filter(Type == 'S-phase') %>%
    arrange(mean_ploidy_corrected) %>%
    mutate(index = 1:n()) %>%
    dplyr::select(index,
                  Cell,
                  mean_ploidy,
                  mean_ploidy_corrected,
                  basename,
                  group)
# select G1/G2 cells
G1_G2_cells = data %>%
    filter(Type == 'G1/G2 cells')

# select tracks of G1/G2 cells
G1_G2_cells_tracks = all_tracks %>%
    inner_join(G1_G2_cells, by = c('Cell', 'basename', 'group')) %>%
    makeGRangesFromDataFrame(
        seqnames.field  = 'chr',
        start.field = 'start' ,
        end.field = 'end',
        keep.extra.columns = T
    )

#select Sphase traks
Sphase_tracks = all_tracks %>%
    inner_join(selected_data, by = c('Cell', 'basename', 'group')) %>%
    mutate(
        copy_number_corrected = ifelse(
            mean_ploidy == mean_ploidy_corrected,
            copy_number,
            copy_number * mean_ploidy_corrected / mean_ploidy
        )
    ) %>%
    makeGRangesFromDataFrame(
        seqnames.field  = 'chr',
        start.field = 'start' ,
        end.field = 'end',
        keep.extra.columns = T
    )

#free some memory
rm('data')
rm('all_tracks')

#calculate median CNV across a bin for S cells

hits = findOverlaps(bins, Sphase_tracks)

overlaps <-
    pintersect(Sphase_tracks[subjectHits(hits)], bins[queryHits(hits)])

signal_smoothed = cbind(
    as_tibble(bins[queryHits(hits)]) %>% dplyr::select(seqnames, start, end) %>%
        `colnames<-`(c('chr', 'start', 'end')),
    as_tibble(overlaps) %>% dplyr::select(-seqnames, -start, -end)
) %>%
    group_by(index, basename, group, chr, start, end) %>%
    summarise(CN = weightedMedian(x = copy_number_corrected, w =
                                      width, na.rm = T)) %>%
    ungroup()


#free memory
rm('Sphase_tracks')
rm('hits')
rm('overlaps')

#calculate median CNV across a bin across all the G1/G2 cells
hits = findOverlaps(bins, G1_G2_cells_tracks)

overlaps <-
    pintersect(G1_G2_cells_tracks[subjectHits(hits)], bins[queryHits(hits)])

backgroud_smoothed = cbind(
    as_tibble(bins[queryHits(hits)]) %>% dplyr::select(seqnames, start, end) %>%
        `colnames<-`(c('chr', 'start', 'end')),
    as_tibble(overlaps) %>% dplyr::select(-seqnames, -start, -end)
) %>%
    group_by(basename, group, chr, start, end) %>%
    summarise(background = weightedMedian(x = copy_number, w =
                                              width, na.rm = T)) %>%
    ungroup()


#free some space
rm('G1_G2_cells_tracks')
rm('hits')
rm('overlaps')

if ('referenceRT' %in% names(opt)) {
    # rebin reference RT
    Reference_RT = Reference_RT %>%
        drop_na() %>%
        makeGRangesFromDataFrame(
            seqnames.field = 'chr',
            start.field = 'start',
            end.field = 'end',
            keep.extra.columns = T
        )
    
    hits = findOverlaps(bins, Reference_RT)
    
    overlaps <-
        pintersect(Reference_RT[subjectHits(hits)], bins[queryHits(hits)])
    
    Reference_RT = cbind(
        as_tibble(bins[queryHits(hits)]) %>% dplyr::select(seqnames, start, end) %>%
            `colnames<-`(c('chr', 'start', 'end')),
        as_tibble(overlaps) %>% dplyr::select(-seqnames, -start, -end)
    ) %>%
        group_by(chr, start, end) %>%
        summarise(RT = weightedMedian(x = RT, w =
                                          width, na.rm = T)) %>%
        ungroup() %>%
        mutate(chr = factor(x =  chr, levels = chr_list),
               RT = (RT - min(RT)) / (max(RT) - min(RT))) %>%
        ungroup()
    
    
    #write output
    write_delim(
        x = Reference_RT,
        path = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_reference_replication_timing_',
            opt$binsSize,
            '.tsv'
        ),
        delim = '\t',
        col_names = T
    )
    
    rm('hits')
    rm('overlaps')
    
    
}

#merge signal and bg and calculate their ratio
signal_smoothed = signal_smoothed %>%
    ungroup() %>%
    mutate(chr = factor(x =  chr, levels = chr_list)) %>%
    inner_join(backgroud_smoothed,
               by = c("chr", "start", "end", "basename", 'group')) %>%
    mutate(CN_bg = log2(CN / background)) %>%
    drop_na() %>%
    filter(is.finite(CN_bg))

# remove control track
rm('backgroud_smoothed')

# identify threshold that minimazes the difference of the real data with a binary state (1 or 2)
selecte_th = foreach(
    line = unique(signal_smoothed$basename),
    .combine = 'rbind',
    .packages = c('foreach', 'tidyverse')
) %dopar% {
    sub_sig = signal_smoothed %>%
        filter(basename == line)
    
    #identify range within looking for a CNV treshold to define replicated and not replicated values
    range = seq(0, 1, 0.01)
    
    th_temp = foreach(i = range,
                      .combine = 'rbind',
                      .packages = 'tidyverse') %do% {
                          summary = sub_sig %>%
                              mutate(Rep = ifelse(CN_bg >= i, T, F),
                                     Error = (Rep - CN_bg) ^ 2) %>%
                              group_by(index, basename, group)  %>%
                              summarise(summary = sum(Error))
                          
                          data.frame(
                              th = i,
                              basename = summary$basename,
                              index = summary$index,
                              sum_error = summary$summary
                          )
                      }
    th_temp
}

selecte_th = selecte_th %>%
    group_by(index, basename) %>%
    filter(sum_error == min(sum_error)) %>%
    summarise(th = min(th)) %>%
    ungroup

# mark replicated bins
signal_smoothed = signal_smoothed %>%
    inner_join(selecte_th, by = c("index", "basename")) %>%
    mutate(Rep = ifelse(CN_bg >= th, T, F))

#identify new distribution in the S phase based the ammount of replicated bins
new_index_list = signal_smoothed %>%
    group_by(index, basename, group) %>%
    summarise(perc_replication = mean(Rep)) %>%
    ungroup() %>%
    arrange(perc_replication) %>%
    group_by(group) %>%
    mutate(newIndex = 1:n()) %>%
    dplyr::select(index, basename, newIndex, group)

signal_smoothed = signal_smoothed %>%
    inner_join(new_index_list, by = c('index', 'basename', 'group'))

stopCluster(cl)

# bin cells in order to have not unballance RT
signal_smoothed = signal_smoothed %>%
    group_by(index, group) %>%
    mutate(mean_CN = mean(Rep),
           groups = ceiling(mean_CN * 10))

#plot profile binning
plot = signal_smoothed %>%
    group_by(index, group) %>%
    summarise(Rep_percentage = mean(Rep)) %>%
    ggplot(aes(Rep_percentage, color = group)) +
    geom_density(aes(y = ..scaled..)) +
    scale_x_continuous(labels = scales::percent) +
    xlab('Percentage of the genome that has been replicated') +
    ylab('density') + coord_cartesian(xlim = c(0, 1))

suppressMessages(ggsave(
    plot,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_percentage_of_replicating_cells.pdf'
    )
))

#matrix for the correlation
signal_smoothed = signal_smoothed %>%
    ungroup() %>%
    arrange(group, newIndex) %>%
    unite(index, c(group, newIndex), sep = ' _ ') %>%
    mutate(index = factor(index, levels = unique(index)))
mat = signal_smoothed %>%
    unite(pos, c(chr, start), sep = ':') %>%
    mutate(Rep = as.numeric(Rep)) %>%
    dplyr::select(pos, index, Rep) %>%
    spread(key = index, value = Rep) %>%
    column_to_rownames('pos') %>%
    filter(complete.cases(.)) %>%
    as.matrix()

#correlation
results = cor(mat, mat)
basenames = str_remove(colnames(mat), ' _ [0-9]{1,10}$')
Index = colnames(mat)
basename_n = basenames

for (i in 1:length(unique(basename_n))) {
    basename_n[basename_n == unique(basename_n)[i]] = i
}

#write matrix and plot heatmap before filtering
write.matrix(
    x = results,
    file = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_per_cell_before_filtering.mx'
    ),
    sep = '\t'
)

#prepare color patterns
selcol <- colorRampPalette(brewer.pal(12, "Set3"))
color = colorRampPalette(colors = c('blue', 'green', 'yellow', 'orange', 'red'))

color_basebanes = selcol(length(unique(basename_n)))

jpeg(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_plot_per_cell_before_filter.jpg'
    )
)

heatmap.2(
    results,
    trace = "none",
    dendrogram = 'none',
    Colv = F,
    Rowv = F,
    breaks = seq(0, 1, length.out = 101),
    col = color(100),
    density.info =  'density',
    key.title = 'Pearson',
    RowSideColors = color_basebanes[as.numeric(basename_n)],
    ColSideColors = color_basebanes[as.numeric(basename_n)],
    labRow = FALSE,
    labCol = FALSE
)

invisible(dev.off())

#filter cells that do not correlate

to_keep = foreach(i = 1:length(unique(basename_n))) %do% {
    sub_mat = results[basename_n == i, basename_n == i]
    diag(sub_mat) = 0
    ! rowQuantiles(x = sub_mat, probs = 0.95) <= opt$min_correlation
}

to_keep = unlist(to_keep)
results = results[to_keep, to_keep]
basename_n = basename_n[to_keep]
Index = Index[to_keep]

write.matrix(
    x = results,
    file = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_per_cell_after_filtering.mx'
    ),
    sep = '\t'
)

color_basebanes = selcol(length(unique(basename_n)))

jpeg(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_plot_per_cell_after_filter.jpg'
    )
)

heatmap.2(
    results,
    trace = "none",
    dendrogram = 'none',
    Colv = F,
    Rowv = F,
    breaks = seq(0, 1, length.out = 101),
    col = color(100),
    density.info =  'density',
    key.title = 'Pearson',
    RowSideColors = color_basebanes[as.numeric(basename_n)],
    ColSideColors = color_basebanes[as.numeric(basename_n)],
    labRow = FALSE,
    labCol = FALSE
)

invisible(dev.off())

#filter out samples that don't correlate ans save
signal_smoothed = signal_smoothed %>%
    filter(index %in% Index) %>%
    separate(index, c('basename', 'index'), sep = ' _ ') %>%
    mutate(basename = factor(basename, level = opt$base_name))

rep_percentage = signal_smoothed %>%
    group_by(basename, index) %>%
    summarise(Rep_percentage = mean(Rep))

plot = rep_percentage %>%
    ggplot(aes(Rep_percentage, color = basename)) +
    geom_density(aes(y = ..scaled..)) +
    scale_x_continuous(labels = scales::percent) +
    xlab('Percentage of the genome that has been replicated') +
    ylab('density') + coord_cartesian(xlim = c(0, 1))

suppressMessages(ggsave(
    plot = plot,
    filename = paste0(
        opt$out,
        opt$output_file_base_name,
        '_percentage_of_replicating_cells_after_filtering.pdf'
    )
))

new_index_list = rep_percentage %>%
    ungroup() %>%
    arrange(Rep_percentage) %>%
    group_by(basename) %>%
    mutate(newIndex = 1:n()) %>%
    dplyr::select(index, newIndex, basename)

signal_smoothed = signal_smoothed %>%
    ungroup() %>%
    inner_join(new_index_list, by = c('index', 'basename')) %>%
    dplyr::select(chr,
                  start,
                  end,
                  CN,
                  background,
                  CN_bg,
                  th,
                  Rep,
                  mean_CN,
                  groups,
                  basename,
                  newIndex)


write_delim(
    x = signal_smoothed,
    path = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_single_cells_CNV_',
        opt$binsSize,
        '.tsv'
    ),
    delim = '\t',
    col_names = T
)

#calculate replication timing normalizing each bin by the number of cells in each bin and then calculating the average of the average
s50 = signal_smoothed %>%
    group_by(chr, start, end, groups, basename) %>%
    summarise(Rep = mean(Rep)) %>%
    ungroup() %>%
    group_by(chr, start, end, basename) %>%
    summarise(RT = mean(Rep)) %>%
    group_by(basename) %>%
    mutate(RT = (RT - min(RT)) / (max(RT) - min(RT)))

write_delim(
    x = s50,
    path = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_calculated_replication_timing_',
        opt$binsSize,
        '.tsv'
    ),
    delim = '\t',
    col_names = T
)

#plots
if (opt$plot) {
    system(paste0('mkdir -p ', opt$out, '/regions'))
    if (!'region' %in% names(opt)) {
        for (i in 1:length(Chr_Size$chr)) {
            region = round(runif(1, min = 1000000, max = 0.8 * Chr_Size$size[i]),
                           0)
            Chr = Chr_Size$chr[i]
            Start = region
            End = region + round(0.2 * Chr_Size$size[i])
            
            # prepare name file
            name_reg = min(str_length(str_extract(Start, '0{1,10}$')),
                           str_length(str_extract(End, '0{1,10}$')))
            name_reg = paste(
                Chr,
                case_when(
                    is.na(name_reg) ~ paste0(Start, 'bp_', End, 'bp'),
                    name_reg < 3 ~ paste0(Start, 'bp_', End, 'bp'),
                    name_reg < 6 ~ paste0(Start / 10 ^ 3, 'Kb_', End / 10 ^
                                              3, 'Kb'),
                    name_reg >= 6 ~ paste0(Start / 10 ^ 6, 'Mb_', End /
                                               10 ^ 6, 'Mb')
                )
            )
            
            
            track_toplot = signal_smoothed %>%
                filter(
                    chr %in% Chr,
                    (start >= Start & end <= End) |
                        (start <= Start & end >= Start) |
                        (start <= End & end >= End)
                ) %>%
                mutate(
                    start = ifelse(start < Start, Start, start),
                    end = ifelse(end > End , End, end)
                )
            
            if (length(track_toplot$chr) != 0) {
                max_index = track_toplot %>% pull(newIndex) %>% max()
                
                s50_toplot = s50 %>%
                    ungroup() %>%
                    filter(
                        chr %in% Chr,
                        (start >= Start & end <= End) |
                            (start <= Start & end >= Start) |
                            (start <= End & end >= End)
                    ) %>%
                    mutate(
                        RT = RT ,
                        start = ifelse(start < Start, Start, start),
                        end = ifelse(end > End , End, end)
                    )
                
                plot =  ggplot() +
                    geom_rect(
                        data = track_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = -newIndex,
                            ymax = -newIndex - 1,
                            fill = as.numeric(Rep)
                        )
                    ) + geom_rect(
                        data = s50_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = 0,
                            ymax = max_index / 20,
                            fill = RT
                        ),
                        inherit.aes = F
                    ) +
                    facet_grid(chr ~ basename, scale = 'free') +
                    scale_fill_gradient(
                        low = 'blue',
                        high = 'red',
                        limits = c(0, 1)
                    ) +
                    scale_x_continuous(
                        labels = function(x)
                            paste(x / 1000000, 'Mb', sep = ' ')
                    ) +
                    labs(y = 'S phase progression', fill = "Replication Timing\nBinary Replication Profile\n") +
                    theme(
                        legend.position = 'top',
                        axis.text.x = element_text(angle = 45, hjust = 1)
                    )
                
                if ('referenceRT' %in% names(opt)) {
                    RT_toplot = Reference_RT %>%
                        filter(
                            chr %in% Chr,
                            (start >= Start & end <= End) |
                                (start <= Start & end >= Start) |
                                (start <= End & end >= End)
                        ) %>%
                        mutate(
                            RT = RT ,
                            start = ifelse(start < Start, Start, start),
                            end = ifelse(end > End , End, end)
                        )
                    if (length(RT_toplot$chr) != 0) {
                        plot = plot +
                            geom_rect(
                                data = RT_toplot,
                                aes(
                                    xmin = start,
                                    xmax = end,
                                    ymin = max_index / 20,
                                    ymax = max_index / 10,
                                    fill = RT
                                ),
                                inherit.aes = F
                            )  +
                            scale_y_discrete(
                                limits = c(
                                    0.075 * max_index,
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c(
                                    opt$ref_name,
                                    'RT',
                                    seq(1,  max_index, round(max_index / 20))
                                )
                            )
                    } else{
                        plot = plot +
                            scale_y_discrete(
                                limits = c(
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c('RT',  seq(
                                    1,  max_index, round(max_index / 20)
                                ))
                            )
                    }
                } else{
                    plot = plot +
                        scale_y_discrete(
                            limits = c(max_index / 40, -seq(
                                1, max_index, round(max_index / 20)
                            )),
                            labels = c('RT',  seq(
                                1,  max_index, round(max_index / 20)
                            ))
                        )
                }
                
                suppressMessages(ggsave(
                    plot,
                    filename = paste0(
                        opt$out,
                        '/regions/',
                        opt$output_file_base_name,
                        '_plot_RT_',
                        name_reg,
                        '.pdf'
                    )
                ))
            }
        }
    } else{
        if (file.exists(opt$region)) {
            #load bed file if exist
            opt$region = read_tsv(opt$region, col_names = c('chr', 'start', 'end')) %>%
                mutate(
                    n_0_start = str_length(str_extract(start, '0{1,10}$')),
                    n_0_end = str_length(str_extract(end, '0{1,10}$')),
                    unit = min(
                        factor(
                            case_when(
                                is.na(n_0_start) ~ 'bp',
                                n_0_start < 3 ~ 'bp',
                                n_0_start < 6 ~ 'Kb',
                                n_0_start >= 6 ~ 'Mp'
                            ),
                            levels = c('bp', 'Kb', 'Mp'),
                            ordered = TRUE
                        ),
                        factor(
                            case_when(
                                is.na(n_0_end) ~ 'bp',
                                n_0_end < 3 ~ 'bp',
                                n_0_end < 6 ~ 'Kb',
                                n_0_end >= 6 ~ 'Mp'
                            ),
                            levels = c('bp', 'Kb', 'Mp'),
                            ordered = TRUE
                        )
                    ),
                    name_reg = paste(
                        chr,
                        case_when(
                            unit == 'bp' ~ paste0(start, unit, '_', end, unit),
                            unit == 'Kb' ~ paste0(start / 10 ^ 3, unit, '_', end /
                                                      10 ^ 3, unit),
                            unit == 'Mb' ~ paste0(start / 10 ^ 6, unit, '_', end /
                                                      10 ^ 6, unit)
                        ),
                        sep = '_'
                    )
                ) %>%
                dplyr::select(-unit, -n_0_start, -n_0_end)
        } else{
            #reshape regions
            opt$region = tibble(coord = str_split(opt$region, pattern = ',')[[1]]) %>%
                mutate(name_reg = str_replace_all(
                    coord,
                    pattern = '[-:]',
                    replacement = '_'
                )) %>%
                separate(coord, c('chr', 'pos'), ':') %>%
                separate(pos, c('start', 'end'), '-') %>%
                mutate(
                    start_unit = str_extract(start, pattern = '.{2}$'),
                    start = as.numeric(str_remove(
                        start, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]"
                    )) * case_when(
                        grepl(x = start_unit, pattern =  '[Kk][Bb]') ~ 1000,
                        grepl(x = start_unit, pattern = '[Mm][Bb]') ~ 1000000,
                        grepl(x = start_unit, pattern = '[Bp][Pp]') ~ 1,
                        grepl(x = start_unit, pattern =  '[0-9][0-9]') ~ 1
                    ),
                    end_unit = str_extract(end, pattern = '.{2}$'),
                    
                    end = as.numeric(str_remove(
                        end, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]"
                    )) * case_when(
                        grepl(x = end_unit, pattern =  '[Kk][Bb]') ~ 1000,
                        grepl(x = end_unit, pattern = '[Mm][Bb]') ~ 1000000,
                        grepl(x = end_unit, pattern = '[Bp][Pp]') ~ 1,
                        grepl(x = end_unit, pattern =  '[0-9][0-9]') ~ 1
                    )
                ) %>%
                dplyr::select(-start_unit, -end_unit)
        }
        
        
        for (i in 1:length(opt$region$chr)) {
            Chr = opt$region$chr[i]
            Start = opt$region$start[i]
            End = opt$region$end[i]
            
            track_toplot = signal_smoothed %>%
                filter(
                    chr %in% Chr,
                    (start >= Start & end <= End) |
                        (start <= Start & end >= Start) |
                        (start <= End & end >= End)
                ) %>%
                mutate(
                    start = ifelse(start < Start, Start, start),
                    end = ifelse(end > End , End, end)
                )
            
            if (length(track_toplot$chr) != 0) {
                max_index = track_toplot %>% pull(newIndex) %>% max()
                
                s50_toplot = s50 %>%
                    ungroup() %>%
                    filter(
                        chr %in% Chr,
                        (start >= Start & end <= End) |
                            (start <= Start & end >= Start) |
                            (start <= End & end >= End)
                    ) %>%
                    mutate(
                        RT = RT,
                        start = ifelse(start < Start, Start, start),
                        end = ifelse(end > End , End, end)
                    )
                
                plot =  ggplot() +
                    geom_rect(
                        data = track_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = -newIndex,
                            ymax = -newIndex - 1,
                            fill = as.numeric(Rep)
                        )
                    ) + geom_rect(
                        data = s50_toplot,
                        aes(
                            xmin = start,
                            xmax = end,
                            ymin = 0,
                            ymax = max_index / 20,
                            fill = RT
                        ),
                        inherit.aes = F
                    ) +
                    facet_grid(chr ~ basename, scale = 'free') +
                    scale_fill_gradient(
                        low = 'blue',
                        high = 'red',
                        limits = c(0, 1)
                    ) +
                    scale_x_continuous(
                        labels = function(x)
                            paste(x / 1000000, 'Mb', sep = ' ')
                    ) +
                    labs(y = 'S phase progression', fill = "RT") +
                    theme(
                        legend.position = 'top',
                        axis.text.x = element_text(angle = 45, hjust = 1)
                    )
                
                
                if ('referenceRT' %in% names(opt)) {
                    RT_toplot = Reference_RT %>%
                        filter(
                            chr %in% Chr,
                            (start >= Start & end <= End) |
                                (start <= Start & end >= Start) |
                                (start <= End & end >= End)
                        ) %>%
                        mutate(
                            RT = RT ,
                            start = ifelse(start < Start, Start, start),
                            end = ifelse(end > End , End, end)
                        )
                    if (length(RT_toplot$chr) != 0) {
                        plot = plot +
                            geom_rect(
                                data = RT_toplot,
                                aes(
                                    xmin = start,
                                    xmax = end,
                                    ymin = max_index / 20,
                                    ymax = max_index / 10,
                                    fill = RT
                                ),
                                inherit.aes = F
                            ) +
                            scale_y_discrete(
                                limits = c(
                                    0.075 * max_index,
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c(
                                    opt$ref_name,
                                    'RT',
                                    seq(1,  max_index, round(max_index / 20))
                                )
                            )
                    } else{
                        plot = plot +
                            scale_y_discrete(
                                limits = c(
                                    max_index / 40,
                                    -seq(1, max_index, round(max_index / 20))
                                ),
                                labels = c('RT',  seq(
                                    1,  max_index, round(max_index / 20)
                                ))
                            )
                    }
                } else{
                    plot = plot +
                        scale_y_discrete(
                            limits = c(max_index / 40, -seq(
                                1, max_index, round(max_index / 20)
                            )),
                            labels = c('RT',  seq(
                                1,  max_index, round(max_index / 20)
                            ))
                        )
                }
                plot = plot + facet_wrap(~ basename)
                suppressMessages(ggsave(
                    plot,
                    filename = paste0(
                        opt$out,
                        '/regions/',
                        opt$output_file_base_name,
                        '_plot_RT_',
                        opt$region$name_reg,
                        '.pdf'
                    )
                ))
            }
        }
    }
}

##### RT distributions
if ('referenceRT' %in% names(opt)) {
    RTs = rbind(
        s50 %>%
            ungroup() %>%
            dplyr::select(chr, start, end, RT, basename),
        
        Reference_RT %>%
            mutate(
                RT = RT / max(RT, na.rm = T),
                basename = opt$ref_name
            )
    )
} else{
    RTs =  s50 %>%
        ungroup() %>%
        dplyr::select(chr, start, end, RT, basename) %>%
        mutate(RT = RT)
}

pdf(
    paste0(
        opt$out,
        '/',
        opt$output_file_base_name
        ,
        '_RT_distribution_plot_calculated_RT_vs_reference.pdf'
    )
)

RTs %>%
    ggplot(aes(RT, fill = basename)) + geom_density(alpha = 0.2, aes(y = ..count.. /
                                                                         sum(..count..))) +
    xlab('RT') + ylab('density')

invisible(dev.off())

##### Correlation Calculated RT and reference
RT_type = unique(RTs$basename)

if (length(RT_type) != 1) {
    results = matrix(
        nrow = length(RT_type),
        ncol = length(RT_type),
        dimnames = list(RT_type, RT_type)
    )
    
    RTs = RTs %>%
        spread(key = basename, value = RT) %>%
        filter(complete.cases(.))
    
    for (i in RT_type) {
        for (h in RT_type) {
            x = RTs[, i] %>%
                pull()
            y = RTs[, h] %>%
                pull()
            results[i, h] = cor.test(x = x,
                                     y = y,
                                     method = 'pearson')$estimate
        }
    }
    
    #preparing colors
    color = colorRampPalette(colors = c('blue', 'green', 'yellow', 'orange', 'red'))
    
    pdf(paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_correlation_plot_RTs.pdf'
    ))
    heatmap.2(
        results,
        cellnote = round(results, 2),
        notecex = 1,
        notecol = 'black',
        trace = "none",
        dendrogram = 'none',
        Colv = FALSE,
        Rowv = FALSE,
        cexRow = 1,
        cexCol = 1,
        lhei = c(1, 3),
        lwid = c(1, 3),
        breaks = seq(0, 1, length.out = 101),
        srtCol = 90,
        srtRow = 0,
        adjRow = 0,
        adjCol = 1,
        density.info = 'density',
        key.title = 'Pearson',
        col = color(100)
    )
    invisible(dev.off())
}

#joing s50 with relative signals
signal_smoothed = signal_smoothed %>%
    dplyr::select(basename, chr, start, end, CN_bg, mean_CN) %>%
    inner_join(s50, by = c("basename", "chr", "start", "end"))  %>%
    group_by(basename) %>%
    mutate(
        CN_bg = 10 * (CN_bg - quantile(CN_bg, c(0.01))[[1]]) / (quantile(CN_bg, c(0.99))[[1]] - quantile(CN_bg, c(0.01))[[1]]),
        RT = 10 * RT,
        mean_CN = round(mean_CN)
    )

#test multiple time windows
cl <- makeCluster(opt$cores)
registerDoSNOW(cl)

x = foreach(bs = unique(s50$basename),
            .combine = 'rbind') %do% {
                sub = signal_smoothed %>%
                    filter(basename == bs)
                
                tmp = foreach(
                    seq = seq(0, 10, 0.05),
                    .combine = 'rbind',
                    .packages = c('tidyverse')
                ) %dopar% {
                    sub %>%
                        mutate(rep = CN_bg <= seq) %>%
                        group_by(chr, start, end, basename, RT, mean_CN) %>%
                        summarise(percentage = mean(rep)) %>%
                        group_by(chr, start, end, basename, RT) %>%
                        summarise(percentage = mean(percentage)) %>%
                        mutate(time = RT - seq) %>%
                        filter(time < 10 ,
                               time > -10)
                    
                }
                tmp
            }

# calculate distance in time per bin
s50_bin = x %>%
    mutate(dist = abs(0.5 - percentage)) %>%
    group_by(basename, chr, start, end) %>%
    filter(dist == min(dist)) %>%
    mutate(time50 = median(time)) %>%
    dplyr::select(-dist, -time, -percentage, -RT)

x = x %>%
    inner_join(s50_bin, by = c("chr", "start", "end", "basename")) %>%
    group_by(basename) %>%
    mutate(
        time = time - time50,
        Cat_RT = case_when(
            RT < 2 ~ '5 - Very Late',
            RT >= 2 & RT < 4 ~ '4 - Late',
            RT >= 4 & RT < 6 ~ '3 - Mid',
            RT >= 6 & RT < 8 ~ '2 - Early',
            RT >= 8 ~ '1 - Very Early'
        ),
        Cat_RT = factor(
            Cat_RT,
            levels = c(
                'All',
                '1 - Very Early',
                '2 - Early',
                '3 - Mid',
                '4 - Late',
                '5 - Very Late'
            )
        )
    )


TW = x %>%
    group_by(chr, start, end, basename) %>%
    mutate(
        t25 = abs(percentage - 0.25),
        t75 = abs(percentage - 0.75),
        t25 = t25 == min(t25),
        t75 = t75 == min(t75)
    ) %>%
    gather(points, filter_colums, t25, t75) %>%
    filter(filter_colums) %>%
    group_by(chr, start, end, basename, points) %>%
    summarise(time = min(time)) %>%
    spread(points, time) %>%
    mutate(TW = abs(t75 - t25)) %>%
    dplyr::select(chr, start, end, basename, TW)

plot = TW %>%
    inner_join(s50, by = c("chr", "start", "end", "basename")) %>%
    ggplot() +
    geom_point(aes(x = RT, y = TW, color = 'basename'), alpha = 0.2) +
    geom_smooth(aes(x = RT, y = TW), color = 'black') +
    facet_wrap( ~ basename)

suppressMessages(ggsave(
    plot,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_variability_plot_all_bins.pdf'
    )
))
write_delim(
    TW,
    path = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_calculated_Twhith_',
        opt$binsSize,
        '.tsv'
    ),
    delim = '\t',
    col_names = T
)

x = rbind(x, x %>%
              mutate(Cat_RT = factor(
                  'All',
                  levels = c(
                      'All',
                      '1 - Very Early',
                      '2 - Early',
                      '3 - Mid',
                      '4 - Late',
                      '5 - Very Late'
                  )
              )))

x %>%
    write_tsv(paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_scRT_variability.tsv'
    ))

#T25_75 function
T25_75 = function(df, name, EL) {
    model = tryCatch(
        nls(percentage ~ SSlogis(time, Asym, xmid, scal),
            data = df[, c('percentage', 'time')]),
        #If the data cannot be fitted with a Gauss-Newton algorithm, try the
        #Golub and Pereyra algorithm for the solution of a nonlinear least squares
        #problem which assumes a number of the parameters are linear.
        #Also, add a higher tolerance (1e-04 Vs 1e-05).
        error = function(e)
            nls(
                percentage ~ SSlogis(time, Asym, xmid, scal),
                data = df[, c('percentage', 'time')],
                algorithm = 'plinear',
                control = nls.control(tol = 1e-04, warnOnly = T)
            )
    )
    min = min(df$time)
    max = max(df$time)
    data = predict(model,
                   newdata = data.frame(time = seq(min, max, 0.01)),
                   type = "l")
    result = data.frame(
        time = seq(min, max, 0.01),
        percentage = data,
        basename = name
    )
    t = result %>%
        mutate(
            distance75 = abs(percentage - 0.75),
            distance25 = abs(percentage - 0.25)
        ) %>%
        mutate(
            min75 = min(distance75),
            min25 = min(distance25),
            t75 = distance75 == min75,
            t25 = distance25 == min25
        ) %>%
        dplyr::select(basename, time, percentage, t75, t25)  %>%
        mutate(Cat_RT = EL)
    
    return(t)
}

#calculate tresholds 25% 75% replication keeping in account early and late domains
fitted_data = foreach(
    basename = unique(x$basename),
    .combine = 'rbind',
    .packages = c('tidyverse', 'foreach')
) %do% {
    temp = foreach(
        EL = unique(x$Cat_RT),
        .combine = 'rbind',
        .packages = c('tidyverse', 'foreach')
    ) %dopar% {
        t = T25_75(df = x[x$basename == basename &
                              x$Cat_RT == EL, ], basename, EL)
    }
    temp
}

t = fitted_data %>% filter(t75 | t25) %>%
    gather('t', 'value', t25, t75) %>%
    filter(value) %>%
    dplyr::select(-percentage, -value) %>%
    spread(t, time) %>%
    mutate(Twidth = abs(t75 - t25))

t %>% write_tsv(paste0(opt$out,
                       '/',
                       opt$output_file_base_name,
                       '_Twidth.tsv'))


p = ggplot(t) +
    geom_col(aes(Cat_RT, Twidth, fill = basename), position = 'dodge') +
    ylab('Twidth') + xlab('')

suppressMessages(ggsave(
    p,
    filename = paste0(opt$out,
                      '/',
                      opt$output_file_base_name,
                      '_Twidths.pdf')
))

p = ggplot() +
    stat_density_2d(
        data = x,
        geom = "polygon",
        aes(
            alpha = ..level..,
            fill = basename,
            y = percentage,
            x = time
        )
    ) +
    geom_line(
        data = fitted_data,
        aes(y = percentage, x = time),
        color = 'blue',
        inherit.aes = F
    ) +
    geom_hline(yintercept = c(0.75, 0.25), color = 'yellow') +
    geom_vline(data = t,
               aes(xintercept = t25),
               color = 'red') +
    geom_vline(data = t,
               aes(xintercept = t75),
               color = 'red') +
    geom_text(
        data = t,
        aes(
            label = paste('Twidth ~', round((t25 - t75), 1), 'h'),
            x = (t25 + (t75 - t25) / 2),
            y = Inf,
            vjust = 1
        ),
        color = 'black',
        inherit.aes = F
    ) +
    facet_grid(basename ~ Cat_RT) +
    ggplot2::scale_x_reverse() +
    scale_y_continuous(labels = scales::percent_format()) +
    ylab('Replicated Bins') +
    theme(legend.position = 'top')

suppressMessages(ggsave(
    p,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_variability_plot.pdf'
    )
))

suppressMessages(ggsave(
    p,
    filename = paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_variability_plot.jpg'
    )
))


if (opt$Var_against_reference) {
    #joing s50 with relative signals
    signal_smoothed = signal_smoothed %>%
        dplyr::select(-RT) %>%
        inner_join(Reference_RT, by = c("chr", "start", "end")) %>%
        group_by(basename) %>%
        mutate(
            CN_bg = 10 * (CN_bg - quantile(CN_bg, c(0.01))[[1]]) / (quantile(CN_bg, c(0.99))[[1]] - quantile(CN_bg, c(0.01))[[1]]),
            RT = 10 * RT
        )
    
    
    #test multiple time windows
    x = foreach(bs = unique(s50$basename),
                .combine = 'rbind') %do% {
                    sub = signal_smoothed %>%
                        filter(basename == bs)
                    
                    tmp = foreach(
                        seq = seq(0, 10, 0.05),
                        .combine = 'rbind',
                        .packages = c('tidyverse')
                    ) %dopar% {
                        sub %>%
                            mutate(rep = CN_bg <= seq) %>%
                            group_by(chr, start, end, basename, RT, mean_CN) %>%
                            summarise(percentage = mean(rep)) %>%
                            group_by(chr, start, end, basename, RT) %>%
                            summarise(percentage = mean(percentage)) %>%
                            mutate(time = RT - seq) %>%
                            filter(time < 10 ,
                                   time > -10)
                        
                    }
                    tmp
                }
    
    
    # calculate distance in time per bin
    RT_ref_bins = x %>%
        mutate(dist = abs(0.5 - percentage)) %>%
        group_by(basename, chr, start, end) %>%
        filter(dist == min(dist)) %>%
        mutate(time50 = median(time)) %>%
        dplyr::select(-dist, -time, -percentage, -RT)
    
    x = x %>%
        inner_join(RT_ref_bins, by = c("chr", "start", "end", "basename")) %>%
        group_by(basename) %>%
        mutate(
            time = time - time50,
            Cat_RT = case_when(
                RT < 2 ~ '5 - Very Late',
                RT >= 2 & RT < 4 ~ '4 - Late',
                RT >= 4 & RT < 6 ~ '3 - Mid',
                RT >= 6 & RT < 8 ~ '2 - Early',
                RT >= 8 ~ '1 - Very Early'
            ),
            Cat_RT = factor(
                Cat_RT,
                levels = c(
                    'All',
                    '1 - Very Early',
                    '2 - Early',
                    '3 - Mid',
                    '4 - Late',
                    '5 - Very Late'
                )
            )
        )
    
    
    TW = x %>%
        group_by(chr, start, end, basename) %>%
        mutate(
            t25 = abs(percentage - 0.25),
            t75 = abs(percentage - 0.75),
            t25 = t25 == min(t25),
            t75 = t75 == min(t75)
        ) %>%
        gather(points, filter_colums, t25, t75) %>%
        filter(filter_colums) %>%
        group_by(chr, start, end, basename, points) %>%
        summarise(time = min(time)) %>%
        spread(points, time) %>%
        mutate(TW = abs(t75 - t25)) %>%
        dplyr::select(chr, start, end, basename, TW)
    
    plot = TW %>%
        inner_join(Reference_RT, by = c("chr", "start", "end")) %>%
        ggplot() +
        geom_point(aes(x = RT, y = TW, color = 'basename'), alpha = 0.2) +
        geom_smooth(aes(x = RT, y = TW), color = 'black') +
        facet_wrap( ~ basename)
    
    suppressMessages(ggsave(
        plot,
        filename = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_variability_plot_all_bins_over_reference_RT.pdf'
        )
    ))
    write_delim(
        TW,
        path = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_calculated_Twhith_over_reference_RT',
            opt$binsSize,
            '.tsv'
        ),
        delim = '\t',
        col_names = T
    )
    
    
    
    x = rbind(x, x %>%
                  mutate(Cat_RT = factor(
                      'All',
                      levels = c(
                          'All',
                          '1 - Very Early',
                          '2 - Early',
                          '3 - Mid',
                          '4 - Late',
                          '5 - Very Late'
                      )
                  )))
    x %>%
        write_tsv(
            paste0(
                opt$out,
                '/',
                opt$output_file_base_name,
                '_scRT_variability_on_reference.tsv'
            )
        )
    
    #calculate tresholds 25% 75% replication keeping in account early and late domains
    fitted_data = foreach(
        basename = unique(x$basename),
        .combine = 'rbind',
        .packages = c('tidyverse', 'foreach')
    ) %do% {
        temp = foreach(
            EL = unique(x$Cat_RT),
            .combine = 'rbind',
            .packages = c('tidyverse', 'foreach')
        ) %dopar% {
            t = T25_75(df = x[x$basename == basename &
                                  x$Cat_RT == EL, ], basename, EL)
        }
        temp
    }
    
    t = fitted_data %>% filter(t75 | t25) %>%
        gather('t', 'value', t25, t75) %>%
        filter(value) %>%
        dplyr::select(-percentage, -value) %>%
        spread(t, time) %>%
        mutate(Twidth = abs(t75 - t25))
    
    t %>% write_tsv(paste0(
        opt$out,
        '/',
        opt$output_file_base_name,
        '_Twidth_ref_RT.tsv'
    ))
    
    
    p = ggplot(t) +
        geom_col(aes(Cat_RT, Twidth, fill = basename), position = 'dodge') +
        ylab('Twidth') + xlab('')
    
    suppressMessages(ggsave(
        p,
        filename = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_Twidths_ref_RT.pdf'
        )
    ))
    
    p = ggplot() +
        stat_density_2d(
            data = x,
            geom = "polygon",
            aes(
                alpha = ..level..,
                fill = basename,
                y = percentage,
                x = time
            )
        ) +
        geom_line(
            data = fitted_data,
            aes(y = percentage, x = time),
            color = 'blue',
            inherit.aes = F
        ) +
        geom_hline(yintercept = c(0.75, 0.25), color = 'yellow') +
        geom_vline(data = t,
                   aes(xintercept = t25),
                   color = 'red') +
        geom_vline(data = t,
                   aes(xintercept = t75),
                   color = 'red') +
        geom_text(
            data = t,
            aes(
                label = paste('Twidth ~', round((t25 - t75), 1), 'h'),
                x = (t25 + (t75 - t25) / 2),
                y = Inf,
                vjust = 1
            ),
            color = 'black',
            inherit.aes = F
        ) +
        facet_grid(basename ~ Cat_RT) +
        ggplot2::scale_x_reverse() +
        scale_y_continuous(labels = scales::percent_format()) +
        ylab('Percentage of cells') +
        theme(legend.position = 'top')
    
    suppressMessages(ggsave(
        p,
        filename = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_variability_plot_Early_Late_ref_RT.pdf'
        )
    ))
    
    suppressMessages(ggsave(
        p,
        filename = paste0(
            opt$out,
            '/',
            opt$output_file_base_name,
            '_variability_plot_Early_Late_ref_RT.jpg'
        )
    ))
    
}

stopCluster(cl)


print('done')
