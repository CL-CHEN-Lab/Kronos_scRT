#parse input
suppressPackageStartupMessages(library(optparse, quietly = TRUE))

options(stringsAsFactors = FALSE,
        dplyr.summarise.inform=FALSE,
        warn = 1,
        scipen = 999)

option_list = list(
    make_option(
        c("-F", "--file"),
        type = "character",
        default = NULL,
        help = "Per cell stat file, to merge multiple runs separate directories with a comma",
        metavar = "character"
    ),
    make_option(
        c("-S", "--settings_file"),
        type = "character",
        help = "File generated by Kronos diagnostic, to merge multiple runs separate directories with a comma",
        metavar = "character"
    ),
    make_option(
        c("-D", "--directory"),
        type = "character",
        default = NULL,
        help = "Single cell Bamfiles directory, to merge multiple runs separate directories with a comma",
        metavar = "character"
    ),
    make_option(
        c("-o", "--out"),
        type = "character",
        default = "output",
        help = "Output directory [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-b", "--base_name"),
        type = "character",
        default = "exp",
        help = "Base name for files names [default= %default]",
        metavar = "character"
    ),
    make_option(
        c("-c", "--cores"),
        type = "integer",
        default = 3,
        help = "Number of parallel jobs to run [default= %default] ",
        metavar = "integer"
    ),
    make_option(
        c("-R","--bin_size"),
        type = "character",
        default = "50Kb",
        action = 'store',
        help = "Bins size in bp,multiple bin size can be provided separated by a comma. [default= %default]",
        metavar = "integer"
    ),
    make_option(
        c("-C", "--chrSizes"),
        type = "character",
        default = NULL,
        help = "Chromosome size file",
        metavar = "character"
    ),
    make_option(
        c("-B","--black_list"),
        type = "character",
        action = 'store',
        help = "Regions to ignore",
        metavar = "character"
    ),
    make_option(
        c("--chr_prefix"),
        type = "character",
        action = 'store',
        help = "Chromosome prefix, if there is no prefix use none [default= %default]",
        default = "chr",
        metavar = "character"
    ),
    make_option(
        c("--chr_range"),
        type = "character",
        action = 'store',
        help = "Chromosomes to consider in the analysis (example 1:5,8,15:18,X) [default= %default]",
        default = "1:22",
        metavar = "character"
    )
)


#recover inputs
opt = parse_args(object = OptionParser(option_list = option_list))

#load libraries
suppressPackageStartupMessages(library(tidyverse, quietly = TRUE))
suppressPackageStartupMessages(library(GenomicRanges, quietly = TRUE))
suppressPackageStartupMessages(library(foreach, quietly = TRUE))
suppressPackageStartupMessages(library(doSNOW, quietly = TRUE))
suppressPackageStartupMessages(library(matrixStats, quietly = TRUE))
suppressPackageStartupMessages( library(Rsamtools, quietly = TRUE))


#check inputs
if (!'file' %in% names(opt)) {
    stop("Per cell stat file must be provided. See script usage (--help)")
}

if (!"directory" %in% names(opt)) {
    stop("Directory to bam files not provided. See script usage (--help)")
}

if (!'settings_file' %in% names(opt)) {
    stop("File containing settings sizes must be provided. See script usage (--help)")
}

if (!'chrSizes' %in% names(opt)) {
    stop("File containing Chromosomes sizes must be provided. See script usage (--help)")
}

#create directory
#create output directory
if (!dir.exists(opt$out)) {
    dir.create(opt$out,recursive = T)
}

#load files
opt$file = str_split(opt$file, ',')[[1]]

opt$settings_file = str_split(opt$settings_file, ',')[[1]]

opt$directory = str_split(opt$directory, ',')[[1]]

opt$bin_size = str_split(opt$bin_size, ',')[[1]]
extract_unit=str_extract(opt$bin_size,pattern = '.{2}$')
opt$bin_size = as.numeric(str_remove(opt$bin_size, "[Bb][Pp]|[Kk][Bb]|[Mm][Bb]")) * case_when(
    grepl(x =extract_unit,pattern =  '[Kk][Bb]') ~ 1000,
    grepl(x =extract_unit, pattern = '[Mm][Bb]') ~ 1000000,
    grepl(x =extract_unit, pattern = '[Bp][Pp]') ~ 1,
    grepl(x = extract_unit,pattern =  '[0-9][0-9]') ~ 1
)

if(any(is.na(opt$bin_size)) & length(opt$bin_size) >1){
    warning('some binsize have an incorrect format and will be excluded')
    opt$bin_size=opt$bin_size[!is.na(opt$bin_size)]
}else if(any(is.na(opt$bin_size)) & length(opt$bin_size) == 1){
    stop('binsize have an incorrect format')
}else if(any(opt$bin_size < 1000) & length(opt$bin_size) >1){
    opt$bin_size=opt$bin_size[opt$bin_size > 200]
    warning('some binsize are smaller than 1Kb and they will ingnored')
}else if(any(opt$bin_size < 1000) & length(opt$bin_size) == 1){
    opt$bin_size=opt$bin_size[opt$bin_size > 200]
    stop('binsize has to be at least 1Kb')
}

if('black_list' %in% names(opt)){
    bl=read_tsv(opt$black_list,col_names = c('chr','start','end'),col_types = cols(chr='c'))%>%
        makeGRangesFromDataFrame()
}

files = foreach(
    f = 1:length(opt$file),
    .combine = 'rbind',
    .packages = 'tidyverse'
) %do% {
    read_csv(opt$file[f], col_types = cols())%>%
        mutate(group=f,
               Cell=file.path(opt$directory[[f]],Cell))
}

settings = foreach(
    s = 1:length(opt$settings_file),
    .combine = 'rbind',
    .packages = 'tidyverse'
) %do% {
    read_tsv(opt$settings_file[s], col_types = cols()) %>%
        mutate(group = s)
}

files=files%>%
    inner_join(settings,Joining, by = "group")%>%
    mutate(
        phase=case_when(
            normalized_dimapd < threshold_G1G2phase ~ 'G1/G2',
            normalized_dimapd > threshold_Sphase ~ 'S',
            T ~ 'NA'
        ))%>%
    filter(phase != 'NA')%>%
    dplyr::select(Cell,phase,group)

#check single or paired end
seq_type=Vectorize(function(x){
    if(!file.exists(paste0(x,'.bai'))){
        indexBam(x)
    }
    return(testPairedEndBam(x))
},vectorize.args = 'x')

is_paired=files%>%
    group_by(group)%>%
    summarise(file=Cell[1])%>%
    mutate(is_paired=testPairedEndBam(file))%>%
    dplyr::select(group,is_paired)

files=files%>%inner_join(is_paired,Joining, by = "group")
# select chrs of interest
# convert string into range
Convert_to_range = Vectorize(function(x){
    if (str_detect(x, ':')) {
        x = str_split(x, ':')[[1]]
        return(as.numeric(x[1]):as.numeric(x[2]))
    } else{
        return(x)
    }
})

#select chrs
chr_list = paste0(ifelse(opt$chr_prefix=='none','',opt$chr_prefix), unlist(Convert_to_range(str_split(opt$chr_range,',')[[1]])))

#load bins
ChrSize=read_tsv(opt$chrSizes,col_names =c('chr','size'), col_types = c(chr='c'))%>%
    filter(chr %in% chr_list)

bins_200=ChrSize%>%
    rowwise()%>%
    mutate(start=list(seq(0,size-200,200)))%>%
    unnest(start)%>%
    mutate(end=start+199)%>%
    makeGRangesFromDataFrame()


# free memory
rm('settings')

cl <- makeCluster(opt$cores)
registerDoSNOW(cl)

results=foreach(phase=unique(files$phase),.combine = 'rbind',.packages = c('tidyverse','GenomicRanges','matrixStats','Rsamtools','foreach'),.inorder = T)%do%{
    bins_200$reads=foreach(f=which(files$phase==phase),.combine = '+',.packages = c('tidyverse','GenomicRanges','matrixStats','Rsamtools','foreach'))%dopar%{

        if(!file.exists(paste0(files$Cell[f],'.bai'))){
            indexBam(file)
        }
        if(files$is_paired[f]){
            param <-
                ScanBamParam(
                    what = c('rname', 'pos', 'mapq'),
                    flag = scanBamFlag(
                        isPaired = T,
                        isUnmappedQuery = F,
                        isFirstMateRead = T,
                        isDuplicate = F,
                        isProperPair = T
                    ),
                    mapqFilter = 30
                )

            sam=scanBam(files$Cell[f], param = param)%>%
                as.data.frame()%>%
                makeGRangesFromDataFrame(seqnames.field = 'rname',
                                         start.field = 'pos',
                                         end.field = 'pos')


            countOverlaps(query = bins_200,subject = sam)


        }else{
            param <-
                ScanBamParam(
                    what = c('rname', 'pos', 'mapq'),
                    flag = scanBamFlag(isUnmappedQuery = F,
                                       isDuplicate = F),
                    mapqFilter = 30
                )

            sam=scanBam(files$Cell[f], param = param)%>%
                as.data.frame()%>%
                makeGRangesFromDataFrame(seqnames.field = 'rname',
                                         start.field = 'pos',
                                         end.field = 'pos')


            countOverlaps(query = bins_200,subject = sam)
        }

    }

    extreme_values=quantile(bins_200$reads,0.995)[[1]]

    bins_200$reads[ bins_200$reads > extreme_values]= 0

    if('black_list' %in% opt){
        hits=findOverlaps(subject = bl , query = bins_200,minoverlap = 100)
        bins_200$reads[queryHits(hits)]=0
    }


   bins=foreach(bs=opt$bin_size,.combine = 'rbind',.packages = c('tidyverse','GenomicRanges'),.inorder = T)%do%{

    bins_user=ChrSize%>%
        rowwise()%>%
        mutate(start=list(seq(0,size-bs,bs)))%>%
        unnest(start)%>%
        mutate(end=start+bs-1)%>%
        makeGRangesFromDataFrame()


    hits=findOverlaps(subject = bins_user , query = bins_200)

    bins_user[subjectHits(hits)]%>%
        as_tibble()%>%
        mutate(reads=bins_200$reads[queryHits(hits)])%>%
        group_by(seqnames,start,end)%>%
        summarise(reads=sum(reads))%>%
        ungroup()%>%
        mutate(Phase=phase,
               end=end+1,
               bin_size=bs)
   }
   bins
}

results= results%>%
    spread(value = reads,key = Phase)%>%
    group_by(bin_size)%>%
    mutate(G1=1000000*`G1/G2`/sum(`G1/G2`,na.rm = T),
           S=1000000*S/sum(S,na.rm = T),
           RT=ifelse(G1==0|S==0,NA,log2(S/G1)),
           RT=ifelse(RT>quantile(RT,0.995,na.rm = T)[[1]] | RT < quantile(RT,0.005,na.rm = T)[[1]],NA,RT),
           RT=(RT-min(RT,na.rm = T))/(max(RT,na.rm = T)-min(RT,na.rm = T)))%>%
    dplyr::select('chr'=seqnames,start,end,G1,S,RT,bin_size)%>%
    ungroup()

x=foreach(bs=opt$bin_size)%dopar%{

    extract_unit = case_when(
        is.na(str_length(str_extract(bs,'0{1,10}$'))) ~ paste0(bs,'bp'),
        str_length(str_extract(bs,'0{1,10}$')) < 3 ~ paste0(bs,'bp'),
        str_length(str_extract(bs,'0{1,10}$')) < 6 ~ paste0(bs/10^3,'Kb'),
        str_length(str_extract(bs,'0{1,10}$')) >= 6  ~ paste0(bs/10^6,'Mb'))

    results %>%
        filter(bin_size == bs) %>%
        dplyr::select(-bin_size) %>%
        write_delim(
            path = file.path(opt$out,paste0(
                          opt$base_name,
                          '_population_RT_',
                          extract_unit,
                          '.tsv')),
            delim = '\t',
            col_names = T
        )
    bs
}
print('done')

